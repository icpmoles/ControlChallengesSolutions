[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Control Theory: Tutorial with Julia",
    "section": "",
    "text": "0.1 Intro\nThis is a collection of write ups on how to solve the various problems presented by Github user “Janismac”.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "index.html#what-do-i-need",
    "href": "index.html#what-do-i-need",
    "title": "Control Theory: Tutorial with Julia",
    "section": "0.2 What do I need?",
    "text": "0.2 What do I need?\n\n0.2.1 Software\n\nA real OS like Linux or Windows. 1\nThe Julia Programming Language\n\nClone the repo\nActivate the package by running in your terminal:\njulia --project -e 'using Pkg; Pkg.instantiate()'\n\n(Nice to have) OpenModelica Editor\n\n1 MacOs should be supported in theory but it’s not tested.\n\n0.2.2 Theory\n\nBasic Julia knowledge\nBasic JS knowledge\nControl Theory knowledge\n\nFrequency Based Control\nState Space Based control\n\nMisc knowledge:\n\nLinear Algebra\nDifferential Equations",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "block_on_slope/model.html",
    "href": "block_on_slope/model.html",
    "title": "2  The Damped Mass problem",
    "section": "",
    "text": "2.1 Modeling\nTo better understand the problem let’s take a peek at how the simulated model works.\n\\[\n\\begin{cases}\n\\dot s = v \\\\\n\\dot v = F - sin(\\alpha) \\cdot g - \\mu \\cdot v \\\\\n\\dot F = -20 \\cdot F + 20 \\cdot u_{sat} \\\\\n\\end{cases}\n\\]\nConverting it in state-space representation:\n\\[\n\\begin{bmatrix}\n\\dot s \\\\ \\dot v \\\\ \\dot F\n\\end{bmatrix} = \\begin{bmatrix}\n0 & 1 & 0 \\\\\n0&  -\\mu & 1\\\\\n0 & 0 & -20\n\\end{bmatrix}\n\\begin{bmatrix}\ns \\\\ v \\\\ F\n\\end{bmatrix} +\n\\begin{bmatrix}\n0 \\\\ 0 \\\\ u_{sat}\n\\end{bmatrix} +\n\\begin{bmatrix}\n0 \\\\ - sin(\\alpha) \\cdot g \\\\ 0\n\\end{bmatrix}\n\\]\n\\[\n\\begin{bmatrix}\ns \\\\ v\n\\end{bmatrix} =\n\\begin{bmatrix}\n1 & 0 & 0 \\\\\n0& 1 & 0\n\\end{bmatrix}\n\\begin{bmatrix}\ns \\\\ v \\\\ F\n\\end{bmatrix}\n\\]\nObviously the gravitational term acts as a disturbance.",
    "crumbs": [
      "Block on a Slope",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>The Damped Mass problem</span>"
    ]
  },
  {
    "objectID": "block_on_slope/model.html#modeling",
    "href": "block_on_slope/model.html#modeling",
    "title": "2  The Damped Mass problem",
    "section": "",
    "text": "BlockOnSlope.js\n\nModels.BlockOnSlope.prototype.vars = \n1{\n    g: 9.81,\n    x: 0,          // distance from objective s\n    dx: 0,         // velocity v\n    slope: 1,      // slope coefficient alpha = dy/dx in the cartesian plane\n    F: 0,          // Requested u\n    F_cmd: 0,      // Saturated u\n    friction: 0,   // Coulomb friction coefficient mu\n    T: 0,          // Simulation Time\n};\n\nModels.BlockOnSlope.prototype.simulate = function (dt, controlFunc)\n{\n    this.F_cmd = controlFunc({x:this.x,dx:this.dx,T:this.T});\n    if(typeof this.F_cmd != 'number' || isNaN(this.F_cmd)) throw \"Error: The controlFunction must return a number.\";\n2    this.F_cmd = Math.max(-20,Math.min(20,this.F_cmd));\n    integrationStep(this, ['x', 'dx', 'F'], dt);\n}\n\nModels.BlockOnSlope.prototype.ode = function (x)\n{\n    return [\n3        x[1],\n        (x[2]) - (Math.sin(this.slope) * this.g) - (this.friction * x[1]),\n        20.0 * (this.F_cmd - x[2])\n    ];\n}\n\n\n1\n\nThe model has obviously some default values for the parameters that can be modified for the different scenarios.\n\n2\n\nThe control command \\(u\\) is generated by the controlFunction(block) function provided by us. There are some checks to see if it’s a number. If it’s acceptable then it passes through a saturation between \\(\\pm20\\).\n\n3\n\nThe model is a simple ODE with equations:",
    "crumbs": [
      "Block on a Slope",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>The Damped Mass problem</span>"
    ]
  },
  {
    "objectID": "block_on_slope/without_friction.html",
    "href": "block_on_slope/without_friction.html",
    "title": "3  Block without Friction",
    "section": "",
    "text": "3.1 State Space representation\nWe can convert the set of ODE into a state space representation. The final bode plot of the block position is:\nCode\nusing DiscretePIDs, ControlSystems, Plots, LinearAlgebra\n\n# System parameters\nTs = 0.02 # sampling time\nTf = 2.5; #final simulation time\ng = 9.81 #gravity\nα = 0.0 # slope\nμ = 1.0 # friction coefficient\nx_0 = -2.0 # starting position\ndx_0 = 0.0 # starting velocity\nτ = 20.0 # torque constant \n\n# State Space Matrix\nA = [0 1 0\n    0 -μ 1\n    0 0 -τ];\nB = [0\n    0\n    τ];\nC = [1 0 0\n    0 1 0];\n\nsys = ss(A, B, C, 0.0)      # Continuous\n\nplot!(bodeplot(tf(sys)),pzmap(tf(sys)))\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStarting Bode Plot and PZ Map\nIt has the shape we expect from a motor + friction. Slow pole for the mass + friction and a faster pole for the current & inductance.\nNumerically they are:\nCode\ndisplay(eigvals(A))\n\n\n3-element Vector{Float64}:\n -20.0\n  -1.0\n   0.0\nWe see that we start with all the pole in the left-half plane, which is good.",
    "crumbs": [
      "Block on a Slope",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Block without Friction</span>"
    ]
  },
  {
    "objectID": "block_on_slope/without_friction.html#pole-placement",
    "href": "block_on_slope/without_friction.html#pole-placement",
    "title": "3  Block without Friction",
    "section": "3.2 Pole Placement",
    "text": "3.2 Pole Placement\nWe can design a controller with pole placement.\nFor some reason pole placement doesn’t work for the observer, I use a Kalman Filter with random fast values.\n\n\nCode\nobservability(A, C).isobservable & \ncontrollability(A, B).iscontrollable; #OK\n\nε = 0.01;\npp = 15.0;\npoles_cont = -2.0 * [pp + ε, pp - ε, pp];\nL = real(place(sys, poles_cont, :c));\n\npoles_obs = poles_cont * 10.0;\nK = place(1.0 * A', 1.0 * C', poles_obs)'\ncont = observer_controller(sys, L, K; direct=false);\n\n\nWe can check the effect of the new controller on the loop\n\n\nCode\nclosedLoop = feedback(sys * cont)\nprint(poles(closedLoop));\nsetPlotScale(\"dB\")\nplot!(bodeplot(closedLoop[1, 1], 0.1:40), pzmap(closedLoop))\n\n\nComplexF64[-29.979998924597755 + 0.0im, -30.000002152199972 + 0.0im, -30.019998923202337 + 0.0im, -300.0000000000004 + 0.0im, -300.1999999999752 + 0.0im, -299.80000000004117 + 0.0im]\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can compare this to the open-loop response in @start-bode. We can see that we achieve unitary gain throughout the whole low-frequency range.\nWe can convert the pole placement controller into the standard PD gain form.\n\n\nCode\nK = L[1];\nTi = 0;\nTd = L[2] / L[1];\npid = DiscretePID(; K, Ts, Ti, Td);",
    "crumbs": [
      "Block on a Slope",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Block without Friction</span>"
    ]
  },
  {
    "objectID": "block_on_slope/without_friction.html#simulation",
    "href": "block_on_slope/without_friction.html#simulation",
    "title": "3  Block without Friction",
    "section": "3.3 Simulation",
    "text": "3.3 Simulation\nWe can simulate this with a motor that only outputs the position:\n\n\nCode\nsysreal = ss(A, B, [1 0 0], 0.0)\nctrl = function (x, t)\n    y = (sysreal.C*x)[] # measurement\n    d = 0 * [1.0]        # disturbance\n    r = 2.0 * (t &gt;= 1) # reference\n    # u = pid(r, y) # control signal\n    # u + d # Plant input is control signal + disturbance\n    # u =1\n    e = x - [r; 0.0; 0.0]\n    e[3] = 0.0 # torque not observable, just ignore it in the final feedback\n    u = -L * e + d\n    u = [maximum([-20.0 minimum([20.0 u])])]\nend\nt = 0:Ts:Tf\n\nres = lsim(sysreal, ctrl, t)\n\ndisplay(plot(res, \n    plotu=true, \n    plotx=true, \n    ploty=false\n    ))\nylabel!(\"u\", sp=1);\nylabel!(\"x\", sp=2);\nylabel!(\"v\", sp=3);\nylabel!(\"T\", sp=4);\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFor more stats:\n\n\nCode\nsi = stepinfo(res);\nplot(si);title!(\"Step Response\")\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can also simulate it in a SIMULINK-like environment:\n\n\nCode\nusing FMI, DifferentialEquations\nfmuPath = abspath(joinpath(@__DIR__,\n  \"..\",\"..\",\n  \"modelica\",\n  \"ControlChallenges\",\n  \"ControlChallenges.BlockOnSlope_Challenges.Examples.WithFriction.fmu\"))\nfmu = loadFMU(fmuPath);\nsimData = simulateME(\n    fmu,\n    (0.0, 5.0);\n    recordValues=[\"blockOnSlope.x\", \n    \"blockOnSlope.xd\", \n    \"blockOnSlope.usat\"],\n    showProgress=false);\nunloadFMU(fmu);\nplot(simData, states=false, timeEvents=false)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThere is a slight difference between the lsim simulation and the FMU simulation. I need to recheck some stuff.",
    "crumbs": [
      "Block on a Slope",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Block without Friction</span>"
    ]
  },
  {
    "objectID": "block_on_slope/with_friction.html",
    "href": "block_on_slope/with_friction.html",
    "title": "4  Block With Friction",
    "section": "",
    "text": "4.1 Response Analysis\nCode\nusing CCS\nusing ControlSystems, Plots, LinearAlgebra, RobustAndOptimalControl\nCCS.setupEnv()\n\ncontSys = CCS.blockModel.csys(;g = 0, α = 0 , μ = 1, τ =20)\nplot!(bodeplot(contSys[1,1]),pzmap(contSys))\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n10\n\n\n0\n\n\n10\n\n\n3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n10\n\n\n−5\n\n\n10\n\n\n0\n\n\nMagnitude \n\n\n\n\n\n\nu → S\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n10\n\n\n0\n\n\n10\n\n\n3\n\n\nFrequency [rad/s]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n−250\n\n\n−200\n\n\n−150\n\n\n−100\n\n\nPhase (deg)\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n−20\n\n\n−15\n\n\n−10\n\n\n−5\n\n\n0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0.00\n\n\n0.25\n\n\n0.50\n\n\n0.75\n\n\n1.00\n\n\nPole-zero map\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStarting Bode Plot and PZ Map\nIt has the shape we expect from a motor + friction. Slow pole for the mass + friction and a faster pole for the current & inductance.\nNumerically they are:\nCode\ndisplay(eigvals(contSys.A))\n\n\n3-element Vector{Float64}:\n -20.0\n  -1.0\n   0.0\nWe see that we start with all the poles in the left-half plane, which is good.",
    "crumbs": [
      "Block on a Slope",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Block With Friction</span>"
    ]
  },
  {
    "objectID": "block_on_slope/with_friction.html#pole-placement",
    "href": "block_on_slope/with_friction.html#pole-placement",
    "title": "4  Block With Friction",
    "section": "4.2 Pole Placement",
    "text": "4.2 Pole Placement\nWe can design a controller with pole placement.\nFor some reason pole placement doesn’t work for the observer, I use a Kalman Filter with random fast values.\n\n\nCode\nobservability(contSys.A,contSys.C).isobservable || error(\"System is not observable\")\ncontrollability(contSys.A,contSys.B).iscontrollable || error(\"System is not controllable\")\n\nε = 0.01;\npp = 15.0;\npoles_cont = - [pp + ε, pp - ε, pp];\nL = real(place(contSys, poles_cont, :c));\n\n\npoles_obs = poles_cont * 10.0;\nK = place(contSys, poles_obs, :o)\nobs_controller = observer_controller(contSys, L, K; direct=false);\nfsf_controller = named_ss(obs_controller, u = [:ref_S, :ref_V], y = [:u]);\n\n\nWe can check the effect of the new controller on the loop\n\n\nCode\nclosedLoop = feedback( contSys * fsf_controller);\nprint(poles(closedLoop));\nsetPlotScale(\"dB\")\nplot!(bodeplot(closedLoop[1,1], 0.1:40), pzmap(closedLoop))\n\n\nComplexF64[-14.990000366343788 + 0.0im, -14.999999266673722 + 0.0im, -15.010000366982666 + 0.0im, -149.99999999999986 + 0.0im, -150.10000000002432 + 0.0im, -149.8999999999607 + 0.0im]\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n10\n\n\n−1\n\n\n10\n\n\n0\n\n\n10\n\n\n1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n−25\n\n\n−20\n\n\n−15\n\n\n−10\n\n\n−5\n\n\n0\n\n\nMagnitude (dB)\n\n\n\n\n\n\nref_S → S\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n10\n\n\n−1\n\n\n10\n\n\n0\n\n\n10\n\n\n1\n\n\nFrequency [rad/s]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n−200\n\n\n−150\n\n\n−100\n\n\n−50\n\n\n0\n\n\nPhase (deg)\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n−150\n\n\n−100\n\n\n−50\n\n\n0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0.00\n\n\n0.25\n\n\n0.50\n\n\n0.75\n\n\n1.00\n\n\nPole-zero map\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can compare this to the open-loop response in @start-bode. We can see that we achieve unitary gain throughout the whole low-frequency range.\nWe can convert the pole placement controller into the standard PD gain form.\n\n\nCode\nusing DiscretePIDs\nTs = 0.02 # sampling time\nTf = 2.5; #final simulation time\n\nK = L[1];\nTi = 0;\nTd = L[2] / L[1];\n\npid = DiscretePID(; K, Ts, Ti, Td);",
    "crumbs": [
      "Block on a Slope",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Block With Friction</span>"
    ]
  },
  {
    "objectID": "block_on_slope/with_friction.html#simulation",
    "href": "block_on_slope/with_friction.html#simulation",
    "title": "4  Block With Friction",
    "section": "4.3 Simulation",
    "text": "4.3 Simulation\nWe can simulate this with a motor that only outputs the position:\n\n\nCode\nsysreal = ss(contSys.A, contSys.B, [1 0 0], 0.0)\nctrl = function (x, t)\n    y = (sysreal.C*x)[] # measurement\n    d = 0 * [1.0]        # disturbance\n    r = 2.0 * (t &gt;= 1) # reference\n    # u = pid(r, y) # control signal\n    # u + d # Plant input is control signal + disturbance\n    # u =1\n    e = x - [r; 0.0; 0.0]\n    e[3] = 0.0 # torque not observable, just ignore it in the final feedback\n    u = -L * e + d\n    u = [maximum([-20.0 minimum([20.0 u])])]\nend\nt = 0:Ts:Tf\n\nres = lsim(sysreal, ctrl, t)\n\ndisplay(plot(res, \n    plotu=true, \n    plotx=true, \n    ploty=false\n    ))\nylabel!(\"u\", sp=1);\nylabel!(\"x\", sp=2);\nylabel!(\"v\", sp=3);\nylabel!(\"T\", sp=4);\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0.0\n\n\n0.5\n\n\n1.0\n\n\n1.5\n\n\n2.0\n\n\n2.5\n\n\nTime (s)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n−20\n\n\n−10\n\n\n0\n\n\n10\n\n\n20\n\n\nu\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0.0\n\n\n0.5\n\n\n1.0\n\n\n1.5\n\n\n2.0\n\n\n2.5\n\n\nTime (s)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0.0\n\n\n0.5\n\n\n1.0\n\n\n1.5\n\n\n2.0\n\n\nx(1)\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0.0\n\n\n0.5\n\n\n1.0\n\n\n1.5\n\n\n2.0\n\n\n2.5\n\n\nTime (s)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0\n\n\n1\n\n\n2\n\n\n3\n\n\n4\n\n\n5\n\n\nx(2)\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0.0\n\n\n0.5\n\n\n1.0\n\n\n1.5\n\n\n2.0\n\n\n2.5\n\n\nTime (s)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n−20\n\n\n−10\n\n\n0\n\n\n10\n\n\n20\n\n\nx(3)\n\n\n\n\n\nFor more stats:\n\n\nCode\nsi = stepinfo(res);\nplot(si);title!(\"Step Response\")\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0.0\n\n\n0.5\n\n\n1.0\n\n\n1.5\n\n\n2.0\n\n\n2.5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0.0\n\n\n0.5\n\n\n1.0\n\n\n1.5\n\n\n2.0\n\n\nStep Response\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFinal value: 2.000\n\n\n\nRise time: 0.360\n\n\n\nRise time threshold: 10.0%-90.0%\n\n\n\n\nPeak: 2.032 Overshoot: 1.6%\n\n\n\n\nSettling time: 1.620\n\n\n\nSettling threshold: 2.0%\n\n\n\n\nUndershoot: 0.0%\n\n\n\n\nWe can also simulate it in a SIMULINK-like environment:\n\n\nCode\nusing FMI, DifferentialEquations\nfmuPath = abspath(joinpath(@__DIR__,\n  \"..\",\"..\",\n  \"modelica\",\n  \"ControlChallenges\",\n  \"ControlChallenges.BlockOnSlope_Challenges.Examples.WithFriction.fmu\"))\nfmu = loadFMU(fmuPath);\nsimData = simulateME(\n    fmu,\n    (0.0, 5.0);\n    recordValues=[\"blockOnSlope.x\", \n    \"blockOnSlope.xd\", \n    \"blockOnSlope.usat\"],\n    showProgress=false);\nunloadFMU(fmu);\nplot(simData, states=false, timeEvents=false)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0\n\n\n1\n\n\n2\n\n\n3\n\n\n4\n\n\n5\n\n\nt [s]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n−20\n\n\n−10\n\n\n0\n\n\n10\n\n\n20\n\n\n\n\n\n\n\n\n\nblockOnSlope.x (1)\n\n\n\nblockOnSlope.xd (2)\n\n\n\nblockOnSlope.usat (7)\n\n\n\nState event(s)\n\n\n\n\nThere is a slight difference between the lsim simulation and the FMU simulation. I need to recheck some stuff.",
    "crumbs": [
      "Block on a Slope",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Block With Friction</span>"
    ]
  },
  {
    "objectID": "block_on_slope/slope.html",
    "href": "block_on_slope/slope.html",
    "title": "5  Block on a slope",
    "section": "",
    "text": "5.1 Response Analysis\nCode\nusing CCS\nusing ControlSystems, Plots, LinearAlgebra, RobustAndOptimalControl\nCCS.setupEnv()\n\ncontSys = CCS.blockModel.csys(;g = 0, α = 0 , μ = 1, τ =20)\nplot!(bodeplot(contSys[1,1]),pzmap(contSys))\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n10\n\n\n0\n\n\n10\n\n\n3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n10\n\n\n−5\n\n\n10\n\n\n0\n\n\nMagnitude \n\n\n\n\n\n\nu → S\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n10\n\n\n0\n\n\n10\n\n\n3\n\n\nFrequency [rad/s]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n−250\n\n\n−200\n\n\n−150\n\n\n−100\n\n\nPhase (deg)\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n−20\n\n\n−15\n\n\n−10\n\n\n−5\n\n\n0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0.00\n\n\n0.25\n\n\n0.50\n\n\n0.75\n\n\n1.00\n\n\nPole-zero map\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStarting Bode Plot and PZ Map\nIt has the shape we expect from a motor + friction. Slow pole for the mass + friction and a faster pole for the current & inductance.\nNumerically they are:\nCode\ndisplay(eigvals(contSys.A))\n\n\n3-element Vector{Float64}:\n -20.0\n  -1.0\n   0.0\nWe see that we start with all the poles in the left-half plane, which is good.",
    "crumbs": [
      "Block on a Slope",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Block on a slope</span>"
    ]
  },
  {
    "objectID": "block_on_slope/slope.html#pole-placement",
    "href": "block_on_slope/slope.html#pole-placement",
    "title": "5  Block on a slope",
    "section": "5.2 Pole Placement",
    "text": "5.2 Pole Placement\nWe can design a controller with pole placement.\nFor some reason pole placement doesn’t work for the observer, I use a Kalman Filter with random fast values.\n\n\nCode\nobservability(contSys.A,contSys.C).isobservable || error(\"System is not observable\")\ncontrollability(contSys.A,contSys.B).iscontrollable || error(\"System is not controllable\")\n\nε = 0.01;\npp = 15.0;\npoles_cont = - [pp + ε, pp - ε, pp];\nL = real(place(contSys, poles_cont, :c));\n\n\npoles_obs = poles_cont * 10.0;\nK = place(contSys, poles_obs, :o)\nobs_controller = observer_controller(contSys, L, K; direct=false);\nfsf_controller = named_ss(obs_controller, u = [:ref_S, :ref_V], y = [:u])\n\n\nNamedStateSpace{Continuous, Float64}\nA = \n  -150.0                         8.033684828490095e-12    0.0\n     1.0915557686859107e-5    -279.9999999999851          1.0\n -3374.9970813429577        -17530.98989999806          -44.0\nB = \n 150.0                        0.9999999999919663\n  -1.0915557686859107e-5    278.9999999999851\n  -0.0014186570429435138  16899.989999998063\nC = \n 168.74992500000002  31.549995000000003  1.2000000000000002\nD = \n 0.0  0.0\n\nContinuous-time state-space model\nWith state  names: x1 x2 x3\n     input  names: ref_S ref_V\n     output names: u\n\n\nWe can check the effect of the new controller on the loop\n\n\nCode\nclosedLoop = feedback( contSys * fsf_controller);\nprint(poles(closedLoop));\nsetPlotScale(\"dB\")\nplot!(bodeplot(closedLoop[1,1], 0.1:40), pzmap(closedLoop))\n\n\nComplexF64[-14.990000366343788 + 0.0im, -14.999999266673722 + 0.0im, -15.010000366982666 + 0.0im, -149.99999999999986 + 0.0im, -150.10000000002432 + 0.0im, -149.8999999999607 + 0.0im]\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n10\n\n\n−1\n\n\n10\n\n\n0\n\n\n10\n\n\n1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n−25\n\n\n−20\n\n\n−15\n\n\n−10\n\n\n−5\n\n\n0\n\n\nMagnitude (dB)\n\n\n\n\n\n\nref_S → S\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n10\n\n\n−1\n\n\n10\n\n\n0\n\n\n10\n\n\n1\n\n\nFrequency [rad/s]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n−200\n\n\n−150\n\n\n−100\n\n\n−50\n\n\n0\n\n\nPhase (deg)\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n−150\n\n\n−100\n\n\n−50\n\n\n0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0.00\n\n\n0.25\n\n\n0.50\n\n\n0.75\n\n\n1.00\n\n\nPole-zero map\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can compare this to the open-loop response in @start-bode. We can see that we achieve unitary gain throughout the whole low-frequency range.\nWe can convert the pole placement controller into the standard PD gain form.\n\n\nCode\nusing DiscretePIDs\nTs = 0.02 # sampling time\nTf = 2.5; #final simulation time\n\nK = L[1];\nTi = 0;\nTd = L[2] / L[1];\n\npid = DiscretePID(; K, Ts, Ti, Td);",
    "crumbs": [
      "Block on a Slope",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Block on a slope</span>"
    ]
  },
  {
    "objectID": "block_on_slope/slope.html#simulation",
    "href": "block_on_slope/slope.html#simulation",
    "title": "5  Block on a slope",
    "section": "5.3 Simulation",
    "text": "5.3 Simulation\nWe can simulate this with a motor that only outputs the position:\n\n\nCode\nsysreal = ss(contSys.A, contSys.B, [1 0 0], 0.0)\nctrl = function (x, t)\n    y = (sysreal.C*x)[] # measurement\n    d = 0 * [1.0]        # disturbance\n    r = 2.0 * (t &gt;= 1) # reference\n    # u = pid(r, y) # control signal\n    # u + d # Plant input is control signal + disturbance\n    # u =1\n    e = x - [r; 0.0; 0.0]\n    e[3] = 0.0 # torque not observable, just ignore it in the final feedback\n    u = -L * e + d\n    u = [maximum([-20.0 minimum([20.0 u])])]\nend\nt = 0:Ts:Tf\n\nres = lsim(sysreal, ctrl, t)\n\ndisplay(plot(res, \n    plotu=true, \n    plotx=true, \n    ploty=false\n    ))\nylabel!(\"u\", sp=1);\nylabel!(\"x\", sp=2);\nylabel!(\"v\", sp=3);\nylabel!(\"T\", sp=4);\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0.0\n\n\n0.5\n\n\n1.0\n\n\n1.5\n\n\n2.0\n\n\n2.5\n\n\nTime (s)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n−20\n\n\n−10\n\n\n0\n\n\n10\n\n\n20\n\n\nu\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0.0\n\n\n0.5\n\n\n1.0\n\n\n1.5\n\n\n2.0\n\n\n2.5\n\n\nTime (s)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0.0\n\n\n0.5\n\n\n1.0\n\n\n1.5\n\n\n2.0\n\n\nx(1)\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0.0\n\n\n0.5\n\n\n1.0\n\n\n1.5\n\n\n2.0\n\n\n2.5\n\n\nTime (s)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0\n\n\n1\n\n\n2\n\n\n3\n\n\n4\n\n\n5\n\n\nx(2)\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0.0\n\n\n0.5\n\n\n1.0\n\n\n1.5\n\n\n2.0\n\n\n2.5\n\n\nTime (s)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n−20\n\n\n−10\n\n\n0\n\n\n10\n\n\n20\n\n\nx(3)\n\n\n\n\n\nFor more stats:\n\n\nCode\nsi = stepinfo(res);\nplot(si);title!(\"Step Response\")\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0.0\n\n\n0.5\n\n\n1.0\n\n\n1.5\n\n\n2.0\n\n\n2.5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0.0\n\n\n0.5\n\n\n1.0\n\n\n1.5\n\n\n2.0\n\n\nStep Response\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFinal value: 2.000\n\n\n\nRise time: 0.360\n\n\n\nRise time threshold: 10.0%-90.0%\n\n\n\n\nPeak: 2.032 Overshoot: 1.6%\n\n\n\n\nSettling time: 1.620\n\n\n\nSettling threshold: 2.0%\n\n\n\n\nUndershoot: 0.0%\n\n\n\n\nWe can also simulate it in a SIMULINK-like environment:\n\n\nCode\nusing FMI, DifferentialEquations\nfmuPath = abspath(joinpath(@__DIR__,\n  \"..\",\"..\",\n  \"modelica\",\n  \"ControlChallenges\",\n  \"ControlChallenges.BlockOnSlope_Challenges.Examples.WithFriction.fmu\"))\nfmu = loadFMU(fmuPath);\nsimData = simulateME(\n    fmu,\n    (0.0, 5.0);\n    recordValues=[\"blockOnSlope.x\", \n    \"blockOnSlope.xd\", \n    \"blockOnSlope.usat\"],\n    showProgress=false);\nunloadFMU(fmu);\nplot(simData, states=false, timeEvents=false)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0\n\n\n1\n\n\n2\n\n\n3\n\n\n4\n\n\n5\n\n\nt [s]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n−20\n\n\n−10\n\n\n0\n\n\n10\n\n\n20\n\n\n\n\n\n\n\n\n\nblockOnSlope.x (1)\n\n\n\nblockOnSlope.xd (2)\n\n\n\nblockOnSlope.usat (7)\n\n\n\nState event(s)\n\n\n\n\nThere is a slight difference between the lsim simulation and the FMU simulation. I need to recheck some stuff.",
    "crumbs": [
      "Block on a Slope",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Block on a slope</span>"
    ]
  },
  {
    "objectID": "appendix/performance.html",
    "href": "appendix/performance.html",
    "title": "Appendix A — Performance tricks",
    "section": "",
    "text": "A.1 Hurwitz Check\nCreate our nice model. Assume to have run the poles function and that you have a vector of eigenvalues. For simplicity I will create an arbitrary vector with the first 100 values in \\(-1\\) and the last 100 values as random around \\(0\\).\nCode\nusing BenchmarkTools\n\nvbig = [zeros(ComplexF64,100).-1 ; rand(ComplexF64,100).-0.5];\n\nvbig[[1,end]]\n\n\n2-element Vector{ComplexF64}:\n                 -1.0 + 0.0im\n -0.20895541504670545 + 0.472586989973956im",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Performance tricks</span>"
    ]
  },
  {
    "objectID": "appendix/performance.html#hurwitz-check",
    "href": "appendix/performance.html#hurwitz-check",
    "title": "Appendix A — Performance tricks",
    "section": "",
    "text": "A.1.1 for loop\nWith a naive approach we check if all the elements are in the LHP: make a function that iterates and returns false if it hits a pole with positive real part.\n\n\nCode\nfunction isHurwitz(v)\n    for i in eachindex(v)\n        if real(v[i])&gt;0.0\n            return false\n        end\n    end\n    return true\nend\n\n@benchmark isHurwitz($(Ref(vbig))[])\n\n\n\nBenchmarkTools.Trial: 10000 samples with 987 evaluations per sample.\n Range (min … max):  50.557 ns … 389.564 ns  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     53.698 ns               ┊ GC (median):    0.00%\n Time  (mean ± σ):   56.542 ns ±  13.874 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n   ▂█▇▃▃▂  ▁                                                 ▂ ▂\n  ▆███████▇█▅▇▇▅▅▅▆▅▄▇▅▅▅▆▄▅▄▄▅▁▄▅▄▁▁▄▃▃▄▄▅▃▅▄▄▄▁▁▁▁▃▁▃▅▄▄▃▁▄█ █\n  50.6 ns       Histogram: log(frequency) by time       121 ns &lt;\n\n Memory estimate: 0 bytes, allocs estimate: 0.\n\n\n\nWe have our baseline. We can probably squeeze out some more performance but I’m still a Julia noob.\n\n\nA.1.2 all()\nLet’s try using some of the built-in declarative functions:\n\n\nCode\n@benchmark all(real($vbig).&lt;=0.0)\n\n\n\nBenchmarkTools.Trial: 10000 samples with 755 evaluations per sample.\n Range (min … max):  179.205 ns …  26.772 μs  ┊ GC (min … max):  0.00% … 98.51%\n Time  (median):     252.848 ns               ┊ GC (median):     0.00%\n Time  (mean ± σ):   422.784 ns ± 879.189 ns  ┊ GC (mean ± σ):  32.07% ± 16.25%\n\n  ▇█▄▁  ▁▄▁                                                     ▂\n  █████▇███▇▇▆▆▆▆▆▄▄▄▃▁▁▁▁▃▁▁▁▁▁▁▁▁▁▁▁▁▁▁▃▁▁▁▁▃▁▁▁▃▃▄▆▆▇▆▇▇▇██▆ █\n  179 ns        Histogram: log(frequency) by time       4.19 μs &lt;\n\n Memory estimate: 1.75 KiB, allocs estimate: 5.\n\n\n\nSimple all(), when given a tuple it checks if all the values are True, otherwise it stops when it encounters the first False.\nWe can see that it’s a tad slower. This is because it’s creating a new vector with just the real parts, then it’s creating a new vector with only the boolean results and then it’s checking if there are any False results.\nThis results in a lot of allocations and wasted resources.\n\n\nCode\n@benchmark all(&lt;=(0.0),real($vbig))\n\n\n\nBenchmarkTools.Trial: 10000 samples with 776 evaluations per sample.\n Range (min … max):  156.314 ns …  27.794 μs  ┊ GC (min … max):  0.00% … 98.27%\n Time  (median):     218.814 ns               ┊ GC (median):     0.00%\n Time  (mean ± σ):   343.515 ns ± 647.150 ns  ┊ GC (mean ± σ):  23.74% ± 15.37%\n\n  ▄█▆▃▂▁▁    ▃▁▁▁▁                                              ▁\n  ████████▇▇▆█████▇▆▆▅▅▅▄▃▄▄▅▄▄▄▁▅▃▃▁▁▁▁▁▄▃▁▁▁▁▁▁▁▃▁▄▆▇▇███▆▅▅▅ █\n  156 ns        Histogram: log(frequency) by time       2.58 μs &lt;\n\n Memory estimate: 1.62 KiB, allocs estimate: 2.\n\n\n\nA smarter way is to skip on of the allocations by creating the vector of real parts and then checking row by row if the non-positivity check fails.\n\n\nCode\n@benchmark all(i -&gt; real(i)&lt;=0.0,$vbig)\n\n\n\nBenchmarkTools.Trial: 10000 samples with 987 evaluations per sample.\n Range (min … max):  49.139 ns … 826.545 ns  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     51.165 ns               ┊ GC (median):    0.00%\n Time  (mean ± σ):   55.618 ns ±  22.280 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n  ▆█▅▃▂▁ ▁                                ▁▂                   ▁\n  ██████▇█▇▇▅▄▆▅▆▇▅▃▆▅▅▄▅▆▄▅▄▅▄▄▄▄▄▃▃▅▅▃▆▆██▇▅▅▄▅▄▄▅▅▄▅▄▅▄▃▁▁▅ █\n  49.1 ns       Histogram: log(frequency) by time       145 ns &lt;\n\n Memory estimate: 0 bytes, allocs estimate: 0.\n\n\n\nWe can do better: Instead of converting into real the full vector it checks element by element if it’s in the LHP. It returns false at the first failure. We finally have a comparable result to the benchmark function but in a more compact way.\nIs it cleaner? That’s subjective.\n\n\nA.1.3 mapreduce()\nFinally we try the MapReduce approach. This allows a better utilization of your processor without the necessity of learning parallel programming.\n\n\nCode\n@benchmark mapreduce(i-&gt;real(i)&lt;=0.0, &, $vbig)\n\n\n\nBenchmarkTools.Trial: 10000 samples with 990 evaluations per sample.\n Range (min … max):  43.737 ns … 747.172 ns  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     44.343 ns               ┊ GC (median):    0.00%\n Time  (mean ± σ):   48.952 ns ±  20.482 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n  █▂▃▁                                  ▁                      ▁\n  █████▆▆▆█▆▅▅▅█▅▇▄█▅▆▅▆▆▄▇▆▄█▄▅▇▇▄▄▆▅▅▆█▇▄▅▄▆▄▄▆▄▅▅▄▄▃▄▁▅▆▄▅▄ █\n  43.7 ns       Histogram: log(frequency) by time       131 ns &lt;\n\n Memory estimate: 0 bytes, allocs estimate: 0.\n\n\n\nWe squeeze the last bit of performance and beat the initial benchmark, not by much but still appreciable.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Performance tricks</span>"
    ]
  }
]