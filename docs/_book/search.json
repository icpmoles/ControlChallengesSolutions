[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Control Challenges: Solutions",
    "section": "",
    "text": "0.1 Intro\nThis is a collection of write ups on how to solve the various problems presented by Github user “Janismac”.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "index.html#what-do-i-need",
    "href": "index.html#what-do-i-need",
    "title": "Control Challenges: Solutions",
    "section": "0.2 What do I need?",
    "text": "0.2 What do I need?\n\n0.2.1 Software\n\nA real OS like Linux or Windows.\nThe Julia Programming Language\n\nClone the repo\nActivate the package by running in your terminal:\njulia --project -e 'using Pkg; Pkg.instantiate()'\n\n(Nice to have) OpenModelica Editor\n\n\n\n0.2.2 Theory\n\nBasic Julia knowledge\nBasic JS knowledge\nControl Theory knowledge\n\nFrequency Based Control\nState Space Based control\n\nMisc knowledge:\n\nLinear Algebra\nDifferential Equations",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "block/model.html",
    "href": "block/model.html",
    "title": "The Damped Mass problem",
    "section": "",
    "text": "Modeling\n\\[\n\\begin{cases}\n\\dot{x}=\\mathbf{A}x + \\mathbf{B}y \\\\\ny = \\mathbf{C}x + \\mathbf{D}y\n\\end{cases}\n\\]",
    "crumbs": [
      "The Damped Mass problem"
    ]
  },
  {
    "objectID": "block/solution_01_01.html",
    "href": "block/solution_01_01.html",
    "title": "2  Block With Friction",
    "section": "",
    "text": "2.1 State Space representation\nWe can convert the set of ODE into a state space representation. The final bode plot of the block position is:\nCode\nusing DiscretePIDs, ControlSystems, Plots, LinearAlgebra\n\n# System parameters\nTs = 0.02 # sampling time\nTf = 2.5; #final simulation time\ng = 9.81 #gravity\nα = 0.0 # slope\nμ = 1.0 # friction coefficient\nx_0 = -2.0 # starting position\ndx_0 = 0.0 # starting velocity\nτ = 20.0 # torque constant \n\n# State Space Matrix\nA = [0 1 0\n    0 -μ 1\n    0 0 -τ];\nB = [0\n    0\n    τ];\nC = [1 0 0\n    0 1 0];\n\nsys = ss(A, B, C, 0.0)      # Continuous\n\nplot!(bodeplot(tf(sys)),pzmap(tf(sys)))\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStarting Bode Plot and PZ Map\nIt has the shape we expect from a motor + friction. Slow pole for the mass + friction and a faster pole for the current & inductance.\nNumerically they are:\nCode\ndisplay(eigvals(A))\n\n\n3-element Vector{Float64}:\n -20.0\n  -1.0\n   0.0\nWe see that we start with all the pole in the left-half plane, which is good.",
    "crumbs": [
      "The Damped Mass problem",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Block With Friction</span>"
    ]
  },
  {
    "objectID": "block/solution_01_01.html#pole-placement",
    "href": "block/solution_01_01.html#pole-placement",
    "title": "2  Block With Friction",
    "section": "2.2 Pole Placement",
    "text": "2.2 Pole Placement\nWe can design a controller with pole placement.\nFor some reason pole placement doesn’t work for the observer, I use a Kalman Filter with random fast values.\n\n\nCode\nobservability(A, C).isobservable & \ncontrollability(A, B).iscontrollable; #OK\n\nε = 0.01;\npp = 15.0;\npoles_cont = -2.0 * [pp + ε, pp - ε, pp];\nL = real(place(sys, poles_cont, :c));\n\npoles_obs = poles_cont * 10.0;\nK = place(1.0 * A', 1.0 * C', poles_obs)'\ncont = observer_controller(sys, L, K; direct=false);\n\n\nWe can check the effect of the new controller on the loop\n\n\nCode\nclosedLoop = feedback(sys * cont)\nprint(poles(closedLoop));\nsetPlotScale(\"dB\")\nplot!(bodeplot(closedLoop[1, 1], 0.1:40), pzmap(closedLoop))\n\n\nComplexF64[-29.979998924597755 + 0.0im, -30.000002152199972 + 0.0im, -30.019998923202337 + 0.0im, -300.0000000000004 + 0.0im, -300.1999999999752 + 0.0im, -299.80000000004117 + 0.0im]\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can compare this to the open-loop response in @start-bode. We can see that we achieve unitary gain throughout the whole low-frequency range.\nWe can convert the pole placement controller into the standard PD gain form.\n\n\nCode\nK = L[1];\nTi = 0;\nTd = L[2] / L[1];\npid = DiscretePID(; K, Ts, Ti, Td);",
    "crumbs": [
      "The Damped Mass problem",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Block With Friction</span>"
    ]
  },
  {
    "objectID": "block/solution_01_01.html#simulation",
    "href": "block/solution_01_01.html#simulation",
    "title": "2  Block With Friction",
    "section": "2.3 Simulation",
    "text": "2.3 Simulation\nWe can simulate this with a motor that only outputs the position:\n\n\nCode\nsysreal = ss(A, B, [1 0 0], 0.0)\nctrl = function (x, t)\n    y = (sysreal.C*x)[] # measurement\n    d = 0 * [1.0]        # disturbance\n    r = 2.0 * (t &gt;= 1) # reference\n    # u = pid(r, y) # control signal\n    # u + d # Plant input is control signal + disturbance\n    # u =1\n    e = x - [r; 0.0; 0.0]\n    e[3] = 0.0 # torque not observable, just ignore it in the final feedback\n    u = -L * e + d\n    u = [maximum([-20.0 minimum([20.0 u])])]\nend\nt = 0:Ts:Tf\n\nres = lsim(sysreal, ctrl, t)\n\ndisplay(plot(res, \n    plotu=true, \n    plotx=true, \n    ploty=false\n    ))\nylabel!(\"u\", sp=1);\nylabel!(\"x\", sp=2);\nylabel!(\"v\", sp=3);\nylabel!(\"T\", sp=4);\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFor more stats:\n\n\nCode\nsi = stepinfo(res);\nplot(si);title!(\"Step Response\")\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can also simulate it in a SIMULINK-like environment:\n\n\nCode\nusing FMI, DifferentialEquations\nfmuPath = abspath(joinpath(@__DIR__,\n  \"..\",\"..\",\n  \"modelica\",\n  \"ControlChallenges\",\n  \"ControlChallenges.BlockOnSlope_Challenges.Examples.WithFriction.fmu\"))\nfmu = loadFMU(fmuPath);\nsimData = simulateME(\n    fmu,\n    (0.0, 5.0);\n    recordValues=[\"blockOnSlope.x\", \n    \"blockOnSlope.xd\", \n    \"blockOnSlope.usat\"],\n    showProgress=false);\nunloadFMU(fmu);\nplot(simData, states=false, timeEvents=false)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThere is a slight difference between the lsim simulation and the FMU simulation. I need to recheck some stuff.",
    "crumbs": [
      "The Damped Mass problem",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Block With Friction</span>"
    ]
  }
]