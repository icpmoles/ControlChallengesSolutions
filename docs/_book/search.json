[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Control Challenges: Solutions",
    "section": "",
    "text": "0.1 Intro\nThis is a collection of write ups on how to solve the various problems presented by Github user “Janismac”.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "index.html#what-do-i-need",
    "href": "index.html#what-do-i-need",
    "title": "Control Challenges: Solutions",
    "section": "0.2 What do I need?",
    "text": "0.2 What do I need?\n\n0.2.1 Software\n\nA real OS like Linux or Windows. 1\nThe Julia Programming Language\n\nClone the repo\nActivate the package by running in your terminal:\njulia --project -e 'using Pkg; Pkg.instantiate()'\n\n(Nice to have) OpenModelica Editor\n\n1 MacOs should be supported in theory but it’s not tested.\n\n0.2.2 Theory\n\nBasic Julia knowledge\nBasic JS knowledge\nControl Theory knowledge\n\nFrequency Based Control\nState Space Based control\n\nMisc knowledge:\n\nLinear Algebra\nDifferential Equations",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "block_on_slope/model.html",
    "href": "block_on_slope/model.html",
    "title": "The Damped Mass problem",
    "section": "",
    "text": "Modeling\nTo better understand the problem let’s take a peek at how the simulated model works.\n\\[\n\\begin{cases}\n\\dot s = v \\\\\n\\dot v = F - sin(\\alpha) \\cdot g - \\mu \\cdot v \\\\\n\\dot F = -20 \\cdot F + 20 \\cdot u_{sat} \\\\\n\\end{cases}\n\\]\nConverting it in state-space representation:\n\\[\n\\begin{bmatrix}\n\\dot s \\\\ \\dot v \\\\ \\dot F\n\\end{bmatrix} = \\begin{bmatrix}\n0 & 1 & 0 \\\\\n0&  -\\mu & 1\\\\\n0 & 0 & -20\n\\end{bmatrix}\n\\begin{bmatrix}\ns \\\\ v \\\\ F\n\\end{bmatrix} +\n\\begin{bmatrix}\n0 \\\\ 0 \\\\ u_{sat}\n\\end{bmatrix} +\n\\begin{bmatrix}\n0 \\\\ - sin(\\alpha) \\cdot g \\\\ 0\n\\end{bmatrix}\n\\]\n\\[\n\\begin{bmatrix}\ns \\\\ v\n\\end{bmatrix} =\n\\begin{bmatrix}\n1 & 0 & 0 \\\\\n0& 1 & 0\n\\end{bmatrix}\n\\begin{bmatrix}\ns \\\\ v \\\\ F\n\\end{bmatrix}\n\\]\nObviously the gravitational term acts as a disturbance.",
    "crumbs": [
      "The Damped Mass problem"
    ]
  },
  {
    "objectID": "block_on_slope/model.html#modeling",
    "href": "block_on_slope/model.html#modeling",
    "title": "The Damped Mass problem",
    "section": "",
    "text": "BlockOnSlope.js\n\nModels.BlockOnSlope.prototype.vars = \n1{\n    g: 9.81,\n    x: 0,          // distance from objective s\n    dx: 0,         // velocity v\n    slope: 1,      // slope coefficient alpha = dy/dx in the cartesian plane\n    F: 0,          // Requested u\n    F_cmd: 0,      // Saturated u\n    friction: 0,   // Coulomb friction coefficient mu\n    T: 0,          // Simulation Time\n};\n\nModels.BlockOnSlope.prototype.simulate = function (dt, controlFunc)\n{\n    this.F_cmd = controlFunc({x:this.x,dx:this.dx,T:this.T});\n    if(typeof this.F_cmd != 'number' || isNaN(this.F_cmd)) throw \"Error: The controlFunction must return a number.\";\n2    this.F_cmd = Math.max(-20,Math.min(20,this.F_cmd));\n    integrationStep(this, ['x', 'dx', 'F'], dt);\n}\n\nModels.BlockOnSlope.prototype.ode = function (x)\n{\n    return [\n3        x[1],\n        (x[2]) - (Math.sin(this.slope) * this.g) - (this.friction * x[1]),\n        20.0 * (this.F_cmd - x[2])\n    ];\n}\n\n\n1\n\nThe model has obviously some default values for the parameters that can be modified for the different scenarios.\n\n2\n\nThe control command \\(u\\) is generated by the controlFunction(block) function provided by us. There are some checks to see if it’s a number. If it’s acceptable then it passes through a saturation between \\(\\pm20\\).\n\n3\n\nThe model is a simple ODE with equations:",
    "crumbs": [
      "The Damped Mass problem"
    ]
  },
  {
    "objectID": "block_on_slope/without_friction.html",
    "href": "block_on_slope/without_friction.html",
    "title": "2  Block without Friction",
    "section": "",
    "text": "2.1 State Space representation\nWe can convert the set of ODE into a state space representation. The final bode plot of the block position is:\nCode\nusing DiscretePIDs, ControlSystems, Plots, LinearAlgebra\n\n# System parameters\nTs = 0.02 # sampling time\nTf = 2.5; #final simulation time\ng = 9.81 #gravity\nα = 0.0 # slope\nμ = 1.0 # friction coefficient\nx_0 = -2.0 # starting position\ndx_0 = 0.0 # starting velocity\nτ = 20.0 # torque constant \n\n# State Space Matrix\nA = [0 1 0\n    0 -μ 1\n    0 0 -τ];\nB = [0\n    0\n    τ];\nC = [1 0 0\n    0 1 0];\n\nsys = ss(A, B, C, 0.0)      # Continuous\n\nplot!(bodeplot(tf(sys)),pzmap(tf(sys)))\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStarting Bode Plot and PZ Map\nIt has the shape we expect from a motor + friction. Slow pole for the mass + friction and a faster pole for the current & inductance.\nNumerically they are:\nCode\ndisplay(eigvals(A))\n\n\n3-element Vector{Float64}:\n -20.0\n  -1.0\n   0.0\nWe see that we start with all the pole in the left-half plane, which is good.",
    "crumbs": [
      "The Damped Mass problem",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Block without Friction</span>"
    ]
  },
  {
    "objectID": "block_on_slope/without_friction.html#pole-placement",
    "href": "block_on_slope/without_friction.html#pole-placement",
    "title": "2  Block without Friction",
    "section": "2.2 Pole Placement",
    "text": "2.2 Pole Placement\nWe can design a controller with pole placement.\nFor some reason pole placement doesn’t work for the observer, I use a Kalman Filter with random fast values.\n\n\nCode\nobservability(A, C).isobservable & \ncontrollability(A, B).iscontrollable; #OK\n\nε = 0.01;\npp = 15.0;\npoles_cont = -2.0 * [pp + ε, pp - ε, pp];\nL = real(place(sys, poles_cont, :c));\n\npoles_obs = poles_cont * 10.0;\nK = place(1.0 * A', 1.0 * C', poles_obs)'\ncont = observer_controller(sys, L, K; direct=false);\n\n\nWe can check the effect of the new controller on the loop\n\n\nCode\nclosedLoop = feedback(sys * cont)\nprint(poles(closedLoop));\nsetPlotScale(\"dB\")\nplot!(bodeplot(closedLoop[1, 1], 0.1:40), pzmap(closedLoop))\n\n\nComplexF64[-29.979998924597755 + 0.0im, -30.000002152199972 + 0.0im, -30.019998923202337 + 0.0im, -300.0000000000004 + 0.0im, -300.1999999999752 + 0.0im, -299.80000000004117 + 0.0im]\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can compare this to the open-loop response in @start-bode. We can see that we achieve unitary gain throughout the whole low-frequency range.\nWe can convert the pole placement controller into the standard PD gain form.\n\n\nCode\nK = L[1];\nTi = 0;\nTd = L[2] / L[1];\npid = DiscretePID(; K, Ts, Ti, Td);",
    "crumbs": [
      "The Damped Mass problem",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Block without Friction</span>"
    ]
  },
  {
    "objectID": "block_on_slope/without_friction.html#simulation",
    "href": "block_on_slope/without_friction.html#simulation",
    "title": "2  Block without Friction",
    "section": "2.3 Simulation",
    "text": "2.3 Simulation\nWe can simulate this with a motor that only outputs the position:\n\n\nCode\nsysreal = ss(A, B, [1 0 0], 0.0)\nctrl = function (x, t)\n    y = (sysreal.C*x)[] # measurement\n    d = 0 * [1.0]        # disturbance\n    r = 2.0 * (t &gt;= 1) # reference\n    # u = pid(r, y) # control signal\n    # u + d # Plant input is control signal + disturbance\n    # u =1\n    e = x - [r; 0.0; 0.0]\n    e[3] = 0.0 # torque not observable, just ignore it in the final feedback\n    u = -L * e + d\n    u = [maximum([-20.0 minimum([20.0 u])])]\nend\nt = 0:Ts:Tf\n\nres = lsim(sysreal, ctrl, t)\n\ndisplay(plot(res, \n    plotu=true, \n    plotx=true, \n    ploty=false\n    ))\nylabel!(\"u\", sp=1);\nylabel!(\"x\", sp=2);\nylabel!(\"v\", sp=3);\nylabel!(\"T\", sp=4);\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFor more stats:\n\n\nCode\nsi = stepinfo(res);\nplot(si);title!(\"Step Response\")\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can also simulate it in a SIMULINK-like environment:\n\n\nCode\nusing FMI, DifferentialEquations\nfmuPath = abspath(joinpath(@__DIR__,\n  \"..\",\"..\",\n  \"modelica\",\n  \"ControlChallenges\",\n  \"ControlChallenges.BlockOnSlope_Challenges.Examples.WithFriction.fmu\"))\nfmu = loadFMU(fmuPath);\nsimData = simulateME(\n    fmu,\n    (0.0, 5.0);\n    recordValues=[\"blockOnSlope.x\", \n    \"blockOnSlope.xd\", \n    \"blockOnSlope.usat\"],\n    showProgress=false);\nunloadFMU(fmu);\nplot(simData, states=false, timeEvents=false)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThere is a slight difference between the lsim simulation and the FMU simulation. I need to recheck some stuff.",
    "crumbs": [
      "The Damped Mass problem",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Block without Friction</span>"
    ]
  },
  {
    "objectID": "block_on_slope/with_friction.html",
    "href": "block_on_slope/with_friction.html",
    "title": "3  Block With Friction",
    "section": "",
    "text": "3.1 Response Analysis\nCode\nusing CCS: blockModel\nusing ControlSystems, Plots, LinearAlgebra, RobustAndOptimalControl\ntheme(:wong2)\ncontSys = blockModel.csys(;g = 0, α = 0 , μ = 1, τ =20)\n\nplot!(bodeplot(contSys[1,1]),pzmap(contSys))\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStarting Bode Plot and PZ Map\nIt has the shape we expect from a motor + friction. Slow pole for the mass + friction and a faster pole for the current & inductance.\nNumerically they are:\nCode\ndisplay(eigvals(contSys.A))\n\n\n3-element Vector{Float64}:\n -20.0\n  -1.0\n   0.0\nWe see that we start with all the poles in the left-half plane, which is good.",
    "crumbs": [
      "The Damped Mass problem",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Block With Friction</span>"
    ]
  },
  {
    "objectID": "block_on_slope/with_friction.html#pole-placement",
    "href": "block_on_slope/with_friction.html#pole-placement",
    "title": "3  Block With Friction",
    "section": "3.2 Pole Placement",
    "text": "3.2 Pole Placement\nWe can design a controller with pole placement.\nFor some reason pole placement doesn’t work for the observer, I use a Kalman Filter with random fast values.\n\n\nCode\nobservability(contSys.A,contSys.C).isobservable || error(\"System is not observable\")\ncontrollability(contSys.A,contSys.B).iscontrollable || error(\"System is not controllable\")\n\nε = 0.01;\npp = 15.0;\npoles_cont = - [pp + ε, pp - ε, pp];\nL = real(place(contSys, poles_cont, :c));\n\n\npoles_obs = poles_cont * 10.0;\nK = place(contSys, poles_obs, :o)\nobs_controller = observer_controller(contSys, L, K; direct=false);\nfsf_controller = named_ss(obs_controller, u = [:ref_S, :ref_V], y = [:u]);\n\n\nWe can check the effect of the new controller on the loop\n\n\nCode\nclosedLoop = feedback( contSys * fsf_controller);\nprint(poles(closedLoop));\nsetPlotScale(\"dB\")\nplot!(bodeplot(closedLoop[1,1], 0.1:40), pzmap(closedLoop))\n\n\nComplexF64[-14.990000366343788 + 0.0im, -14.999999266673722 + 0.0im, -15.010000366982666 + 0.0im, -149.99999999999986 + 0.0im, -150.10000000002432 + 0.0im, -149.8999999999607 + 0.0im]\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can compare this to the open-loop response in @start-bode. We can see that we achieve unitary gain throughout the whole low-frequency range.\nWe can convert the pole placement controller into the standard PD gain form.\n\n\nCode\nusing DiscretePIDs\nTs = 0.02 # sampling time\nTf = 2.5; #final simulation time\n\nK = L[1];\nTi = 0;\nTd = L[2] / L[1];\n\npid = DiscretePID(; K, Ts, Ti, Td);",
    "crumbs": [
      "The Damped Mass problem",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Block With Friction</span>"
    ]
  },
  {
    "objectID": "block_on_slope/with_friction.html#simulation",
    "href": "block_on_slope/with_friction.html#simulation",
    "title": "3  Block With Friction",
    "section": "3.3 Simulation",
    "text": "3.3 Simulation\nWe can simulate this with a motor that only outputs the position:\n\n\nCode\nsysreal = ss(contSys.A, contSys.B, [1 0 0], 0.0)\nctrl = function (x, t)\n    y = (sysreal.C*x)[] # measurement\n    d = 0 * [1.0]        # disturbance\n    r = 2.0 * (t &gt;= 1) # reference\n    # u = pid(r, y) # control signal\n    # u + d # Plant input is control signal + disturbance\n    # u =1\n    e = x - [r; 0.0; 0.0]\n    e[3] = 0.0 # torque not observable, just ignore it in the final feedback\n    u = -L * e + d\n    u = [maximum([-20.0 minimum([20.0 u])])]\nend\nt = 0:Ts:Tf\n\nres = lsim(sysreal, ctrl, t)\n\ndisplay(plot(res, \n    plotu=true, \n    plotx=true, \n    ploty=false\n    ))\nylabel!(\"u\", sp=1);\nylabel!(\"x\", sp=2);\nylabel!(\"v\", sp=3);\nylabel!(\"T\", sp=4);\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFor more stats:\n\n\nCode\nsi = stepinfo(res);\nplot(si);title!(\"Step Response\")\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can also simulate it in a SIMULINK-like environment:\n\n\nCode\nusing FMI, DifferentialEquations\nfmuPath = abspath(joinpath(@__DIR__,\n  \"..\",\"..\",\n  \"modelica\",\n  \"ControlChallenges\",\n  \"ControlChallenges.BlockOnSlope_Challenges.Examples.WithFriction.fmu\"))\nfmu = loadFMU(fmuPath);\nsimData = simulateME(\n    fmu,\n    (0.0, 5.0);\n    recordValues=[\"blockOnSlope.x\", \n    \"blockOnSlope.xd\", \n    \"blockOnSlope.usat\"],\n    showProgress=false);\nunloadFMU(fmu);\nplot(simData, states=false, timeEvents=false)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThere is a slight difference between the lsim simulation and the FMU simulation. I need to recheck some stuff.",
    "crumbs": [
      "The Damped Mass problem",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Block With Friction</span>"
    ]
  },
  {
    "objectID": "block_on_slope/slope.html",
    "href": "block_on_slope/slope.html",
    "title": "4  Block on a slope",
    "section": "",
    "text": "4.1 Response Analysis\nCode\nusing CCS: blockModel\nusing ControlSystems, Plots, LinearAlgebra, RobustAndOptimalControl\n\ncontSys = blockModel.csys(;g = 0, α = 0 , μ = 1, τ =20)\n\nplot!(bodeplot(contSys[1,1]),pzmap(contSys))\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStarting Bode Plot and PZ Map\nIt has the shape we expect from a motor + friction. Slow pole for the mass + friction and a faster pole for the current & inductance.\nNumerically they are:\nCode\ndisplay(eigvals(contSys.A))\n\n\n3-element Vector{Float64}:\n -20.0\n  -1.0\n   0.0\nWe see that we start with all the poles in the left-half plane, which is good.",
    "crumbs": [
      "The Damped Mass problem",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Block on a slope</span>"
    ]
  },
  {
    "objectID": "block_on_slope/slope.html#pole-placement",
    "href": "block_on_slope/slope.html#pole-placement",
    "title": "4  Block on a slope",
    "section": "4.2 Pole Placement",
    "text": "4.2 Pole Placement\nWe can design a controller with pole placement.\nFor some reason pole placement doesn’t work for the observer, I use a Kalman Filter with random fast values.\n\n\nCode\nobservability(contSys.A,contSys.C).isobservable || error(\"System is not observable\")\ncontrollability(contSys.A,contSys.B).iscontrollable || error(\"System is not controllable\")\n\nε = 0.01;\npp = 15.0;\npoles_cont = - [pp + ε, pp - ε, pp];\nL = real(place(contSys, poles_cont, :c));\n\n\npoles_obs = poles_cont * 10.0;\nK = place(contSys, poles_obs, :o)\nobs_controller = observer_controller(contSys, L, K; direct=false);\nfsf_controller = named_ss(obs_controller, u = [:ref_S, :ref_V], y = [:u])\n\n\nNamedStateSpace{Continuous, Float64}\nA = \n  -150.0                         8.033684828490095e-12    0.0\n     1.0915557686859107e-5    -279.9999999999851          1.0\n -3374.9970813429577        -17530.98989999806          -44.0\nB = \n 150.0                        0.9999999999919663\n  -1.0915557686859107e-5    278.9999999999851\n  -0.0014186570429435138  16899.989999998063\nC = \n 168.74992500000002  31.549995000000003  1.2000000000000002\nD = \n 0.0  0.0\n\nContinuous-time state-space model\nWith state  names: x1 x2 x3\n     input  names: ref_S ref_V\n     output names: u\n\n\nWe can check the effect of the new controller on the loop\n\n\nCode\nclosedLoop = feedback( contSys * fsf_controller);\nprint(poles(closedLoop));\nsetPlotScale(\"dB\")\nplot!(bodeplot(closedLoop[1,1], 0.1:40), pzmap(closedLoop))\n\n\nComplexF64[-14.990000366343788 + 0.0im, -14.999999266673722 + 0.0im, -15.010000366982666 + 0.0im, -149.99999999999986 + 0.0im, -150.10000000002432 + 0.0im, -149.8999999999607 + 0.0im]\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can compare this to the open-loop response in @start-bode. We can see that we achieve unitary gain throughout the whole low-frequency range.\nWe can convert the pole placement controller into the standard PD gain form.\n\n\nCode\nusing DiscretePIDs\nTs = 0.02 # sampling time\nTf = 2.5; #final simulation time\n\nK = L[1];\nTi = 0;\nTd = L[2] / L[1];\n\npid = DiscretePID(; K, Ts, Ti, Td);",
    "crumbs": [
      "The Damped Mass problem",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Block on a slope</span>"
    ]
  },
  {
    "objectID": "block_on_slope/slope.html#simulation",
    "href": "block_on_slope/slope.html#simulation",
    "title": "4  Block on a slope",
    "section": "4.3 Simulation",
    "text": "4.3 Simulation\nWe can simulate this with a motor that only outputs the position:\n\n\nCode\nsysreal = ss(contSys.A, contSys.B, [1 0 0], 0.0)\nctrl = function (x, t)\n    y = (sysreal.C*x)[] # measurement\n    d = 0 * [1.0]        # disturbance\n    r = 2.0 * (t &gt;= 1) # reference\n    # u = pid(r, y) # control signal\n    # u + d # Plant input is control signal + disturbance\n    # u =1\n    e = x - [r; 0.0; 0.0]\n    e[3] = 0.0 # torque not observable, just ignore it in the final feedback\n    u = -L * e + d\n    u = [maximum([-20.0 minimum([20.0 u])])]\nend\nt = 0:Ts:Tf\n\nres = lsim(sysreal, ctrl, t)\n\ndisplay(plot(res, \n    plotu=true, \n    plotx=true, \n    ploty=false\n    ))\nylabel!(\"u\", sp=1);\nylabel!(\"x\", sp=2);\nylabel!(\"v\", sp=3);\nylabel!(\"T\", sp=4);\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFor more stats:\n\n\nCode\nsi = stepinfo(res);\nplot(si);title!(\"Step Response\")\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can also simulate it in a SIMULINK-like environment:\n\n\nCode\nusing FMI, DifferentialEquations\nfmuPath = abspath(joinpath(@__DIR__,\n  \"..\",\"..\",\n  \"modelica\",\n  \"ControlChallenges\",\n  \"ControlChallenges.BlockOnSlope_Challenges.Examples.WithFriction.fmu\"))\nfmu = loadFMU(fmuPath);\nsimData = simulateME(\n    fmu,\n    (0.0, 5.0);\n    recordValues=[\"blockOnSlope.x\", \n    \"blockOnSlope.xd\", \n    \"blockOnSlope.usat\"],\n    showProgress=false);\nunloadFMU(fmu);\nplot(simData, states=false, timeEvents=false)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThere is a slight difference between the lsim simulation and the FMU simulation. I need to recheck some stuff.",
    "crumbs": [
      "The Damped Mass problem",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Block on a slope</span>"
    ]
  },
  {
    "objectID": "performance.html",
    "href": "performance.html",
    "title": "5  Performance tricks",
    "section": "",
    "text": "5.1 Hurwitz Check\nCreate our nice model. Assume to have run the poles function and that you have a vector of eigenvalues. For simplicity I will create an arbitrary vector with the first 100 values in \\(-1\\) and the last 100 values as random around \\(0\\).\nCode\nusing BenchmarkTools\n\nvbig = [zeros(ComplexF64,100).-1 ; rand(ComplexF64,100).-0.5];\n\nvbig[[1,end]]\n\n\n2-element Vector{ComplexF64}:\n                 -1.0 + 0.0im\n -0.32810220755480635 + 0.28870163380994607im\nThen with a naive approach we check if all the elements are in the LHP.\nCode\n@benchmark all(real(vbig).&lt;=0)\n\n\n\nBenchmarkTools.Trial: 10000 samples with 232 evaluations per sample.\n Range (min … max):  303.448 ns … 110.452 μs  ┊ GC (min … max):  0.00% … 99.29%\n Time  (median):     343.966 ns               ┊ GC (median):     0.00%\n Time  (mean ± σ):   624.979 ns ±   2.448 μs  ┊ GC (mean ± σ):  29.89% ±  9.51%\n\n  ▇█▅▃▂          ▃▄▃▂▂▂▁                                        ▂\n  ██████▇▇▆▆▆██▆▇████████▇▇▇▆▆▅▅▄▅▄▅▃▁▄▄▅▃▄▅▅▄▄▁▃▄▁▃▃▄▃▁▃▄▁▁▃▄▃ █\n  303 ns        Histogram: log(frequency) by time       2.15 μs &lt;\n\n Memory estimate: 1.78 KiB, allocs estimate: 6.\nThe whole vector of complex numbers gets converted to real and then we check row by row if it’s non-positive. The whole check one by one results in a vector with booleans that gets checked one by one if it contains false values.\nCode\n@benchmark all(&lt;=(0),real(vbig))\n\n\n\nBenchmarkTools.Trial: 10000 samples with 202 evaluations per sample.\n Range (min … max):  392.079 ns … 96.263 μs  ┊ GC (min … max):  0.00% … 99.16%\n Time  (median):     421.287 ns              ┊ GC (median):     0.00%\n Time  (mean ± σ):   629.268 ns ±  1.786 μs  ┊ GC (mean ± σ):  15.99% ±  8.67%\n\n  ██▅▃▂▁           ▂▄▄▂▂▁▁▂▁▁▁                                 ▂\n  ███████▇▆▇▇▆▆▄▃▅▆█████████████▇▆▆▆▇▆▄▄▅▅▄▅▄▅▅▅▅▄▄▄▄▁▃▅▄▄▅▃▃▄ █\n  392 ns        Histogram: log(frequency) by time       1.9 μs &lt;\n\n Memory estimate: 1.62 KiB, allocs estimate: 2.\nFor now we can skip the full evaluation of non-positivity: the first time it encounters a positive numbers it returns false. This improves the performance a little bit.\nCode\n@benchmark all(i -&gt; real(i)&lt;=0,vbig)\n\n\n\nBenchmarkTools.Trial: 10000 samples with 421 evaluations per sample.\n Range (min … max):  234.442 ns …  1.805 μs  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     241.805 ns              ┊ GC (median):    0.00%\n Time  (mean ± σ):   260.356 ns ± 79.541 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n  █▇▄▂▁                                                        ▂\n  ██████████▇▆▇█▆█▆▆▇▇▆▆▅▆▅▇▆▆▅▆▄▅▅▅▅▄▄▅▅▅██▆▄▆▆▆▆▄▅▅▄▄▄▁▅▃▃▄▅ █\n  234 ns        Histogram: log(frequency) by time       684 ns &lt;\n\n Memory estimate: 0 bytes, allocs estimate: 0.\nThis is the final form. Instead of converting into real the full vector it checks element by element if it’s in the LHP. It returns false at the first failure.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Performance tricks</span>"
    ]
  }
]