{
  "hash": "6be0465e8ef6657581abf88dec740d74",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Block With Friction\"\ndate: \"6/2/2025\"\njupyter: julia-1.11\nformat: \n  html: default\n  docx: default\n  pdf: default\n---\n\n## State Space representation\n\nWe can convert the set of ODE into a state space representation. The final bode plot of the block position is: @fig-bode\n\n::: {.cell execution_count=1}\n\n::: {.cell-output .cell-output-display execution_count=12}\n![Starting Bode Plot](solution_01_01_files/figure-pdf/fig-bode-output-1.svg){#fig-bode}\n:::\n:::\n\n\nIt has the shape we expect from a motor + friction. Slow pole for the mass + friction and a faster pole for the current & inductance.\n\nNumerically they are:\n\n::: {#fig-pzmap .cell execution_count=2}\n\n::: {#fig-pzmap-1 .cell-output .cell-output-display}\n```\n3-element Vector{Float64}:\n -20.0\n  -1.0\n   0.0\n```\n\nStarting PZ map\n:::\n\n::: {.cell-output .cell-output-display}\n![](solution_01_01_files/figure-pdf/fig-pzmap-output-2.svg){#fig-pzmap-2}\n:::\n:::\n\n\nIn @fig-pzmap we see that we start with all the pole in the left-half plane, which is good.\n\n## Pole Placement\n\nWe can design a controller with pole placement.\n\nFor some reason pole placement doesn't work for the observer, I use a Kalman Filter with random fast values.\n\n::: {.cell execution_count=3}\n\n::: {.cell-output .cell-output-stdout}\n```\n(isobservable = true, ranks = [3, 3, 3], sigma_min = [0.05255163155979671, 1.0000000000000002, 1.0])(iscontrollable = true, ranks = [3, 3, 3], sigma_min = [18.82217025796643, 0.7247734159618929, 0.46815777001494974])\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n┌ Warning: Max iterations reached\n└ @ ControlSystemsBase C:\\Users\\icpmoles\\.julia\\packages\\ControlSystemsBase\\IeuPW\\src\\synthesis.jl:310\n```\n:::\n:::\n\n\nWe can check the effect of the new controller on the loop\n\n::: {.cell execution_count=4}\n\n::: {.cell-output .cell-output-stdout}\n```\nComplexF64[-150.09999999999997 + 0.0im, -149.89999999999995 + 0.0im, -7.500000000000134 + 0.0im, -29.979999999868912 + 0.0im, -30.020000000130636 + 0.0im, -37.50000000000044 + 0.0im]\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](solution_01_01_files/figure-pdf/cell-5-output-2.svg){}\n:::\n\n::: {.cell-output .cell-output-display}\n![](solution_01_01_files/figure-pdf/cell-5-output-3.svg){}\n:::\n:::\n\n\nFrom what I understand we are interested in the dotted line in the bottom right. See how flat it is.\n\nWe can convert it to the standard PD gain form.\n\n\n\n## Simulation\n\nWe can simulate this with a motor that only outputs the position:\n\n::: {.cell execution_count=6}\n\n::: {.cell-output .cell-output-display execution_count=17}\n![](solution_01_01_files/figure-pdf/cell-7-output-1.svg){}\n:::\n:::\n\n\nFor more stats:\n\n::: {.cell execution_count=7}\n\n::: {.cell-output .cell-output-display execution_count=18}\n![](solution_01_01_files/figure-pdf/cell-8-output-1.svg){}\n:::\n:::\n\n\nWe can also simulate it in a SIMULINK-like environment:\n\n::: {.cell execution_count=8}\n\n::: {.cell-output .cell-output-display execution_count=19}\n![](solution_01_01_files/figure-pdf/cell-9-output-1.svg){}\n:::\n:::\n\n\nThere is a slight difference between the `lsim` simulation and the FMU simulation. I need to recheck some stuff.\n\n",
    "supporting": [
      "solution_01_01_files\\figure-pdf"
    ],
    "filters": []
  }
}