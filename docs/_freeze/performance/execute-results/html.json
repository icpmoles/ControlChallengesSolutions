{
  "hash": "ac52fd076ad2523a7cda4a37fadbabc1",
  "result": {
    "engine": "julia",
    "markdown": "---\ntitle: \"Performance tricks\"\ncode-fold: show\n---\n\n## Hurwitz Check\n\nCreate our nice model.\nAssume to have run the `poles` function and that you have a vector of eigenvalues. For simplicity I will create an arbitrary vector with the first 100 values in $-1$ and the last 100 values as random around $0$.\n\n::: {#2 .cell execution_count=1}\n``` {.julia .cell-code}\nusing BenchmarkTools\n\nvbig = [zeros(ComplexF64,100).-1 ; rand(ComplexF64,100).-0.5];\n\nvbig[[1,end]]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2-element Vector{ComplexF64}:\n                 -1.0 + 0.0im\n -0.32810220755480635 + 0.28870163380994607im\n```\n:::\n:::\n\n\n\n\nThen with a naive approach we check if all the  elements are in the LHP.\n\n\n::: {#4 .cell execution_count=1}\n``` {.julia .cell-code}\n@benchmark all(real(vbig).<=0)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>BenchmarkTools.Trial: 10000 samples with 232 evaluations per sample.\n Range <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-cyan-fg ansi-bold\">min</span> … <span class=\"ansi-magenta-fg\">max</span><span class=\"ansi-bright-black-fg\">):  </span><span class=\"ansi-cyan-fg ansi-bold\">303.448 ns</span> … <span class=\"ansi-magenta-fg\">110.452 μs</span>  <span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>min … max<span class=\"ansi-bright-black-fg\">): </span> 0.00% … 99.29%\n Time  <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-blue-fg ansi-bold\">median</span><span class=\"ansi-bright-black-fg\">):     </span><span class=\"ansi-blue-fg ansi-bold\">343.966 ns               </span><span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>median<span class=\"ansi-bright-black-fg\">):    </span> 0.00%\n Time  <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-green-fg ansi-bold\">mean</span> ± <span class=\"ansi-green-fg\">σ</span><span class=\"ansi-bright-black-fg\">):   </span><span class=\"ansi-green-fg ansi-bold\">624.979 ns</span> ± <span class=\"ansi-green-fg\">  2.448 μs</span>  <span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>mean ± σ<span class=\"ansi-bright-black-fg\">):  </span>29.89% ±  9.51%\n\n  ▇<span class=\"ansi-blue-fg\">█</span>▅▃▂      <span class=\"ansi-green-fg\"> </span>   ▃▄▃▂▂▂▁                                        ▂\n  █<span class=\"ansi-blue-fg\">█</span>████▇▇▆▆▆<span class=\"ansi-green-fg\">█</span>█▆▇████████▇▇▇▆▆▅▅▄▅▄▅▃▁▄▄▅▃▄▅▅▄▄▁▃▄▁▃▃▄▃▁▃▄▁▁▃▄▃ █\n  303 ns<span class=\"ansi-bright-black-fg\">        </span><span class=\"ansi-bright-black-fg\">Histogram: </span><span class=\"ansi-bright-black-fg ansi-bold\">log(</span><span class=\"ansi-bright-black-fg\">frequency</span><span class=\"ansi-bright-black-fg ansi-bold\">)</span><span class=\"ansi-bright-black-fg\"> by time</span>       2.15 μs <span class=\"ansi-bold\">&lt;</span>\n\n Memory estimate<span class=\"ansi-bright-black-fg\">: </span><span class=\"ansi-yellow-fg\">1.78 KiB</span>, allocs estimate<span class=\"ansi-bright-black-fg\">: </span><span class=\"ansi-yellow-fg\">6</span>.</pre>\n```\n:::\n\n:::\n:::\n\n\n\nThe *whole* vector of complex numbers gets converted to real and then we check row by row if it's non-positive. The whole check one by one results in a vector with booleans that gets checked one by one if it contains false values.\n\n\n::: {#6 .cell execution_count=1}\n``` {.julia .cell-code}\n@benchmark all(<=(0),real(vbig))\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>BenchmarkTools.Trial: 10000 samples with 202 evaluations per sample.\n Range <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-cyan-fg ansi-bold\">min</span> … <span class=\"ansi-magenta-fg\">max</span><span class=\"ansi-bright-black-fg\">):  </span><span class=\"ansi-cyan-fg ansi-bold\">392.079 ns</span> … <span class=\"ansi-magenta-fg\">96.263 μs</span>  <span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>min … max<span class=\"ansi-bright-black-fg\">): </span> 0.00% … 99.16%\n Time  <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-blue-fg ansi-bold\">median</span><span class=\"ansi-bright-black-fg\">):     </span><span class=\"ansi-blue-fg ansi-bold\">421.287 ns              </span><span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>median<span class=\"ansi-bright-black-fg\">):    </span> 0.00%\n Time  <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-green-fg ansi-bold\">mean</span> ± <span class=\"ansi-green-fg\">σ</span><span class=\"ansi-bright-black-fg\">):   </span><span class=\"ansi-green-fg ansi-bold\">629.268 ns</span> ± <span class=\"ansi-green-fg\"> 1.786 μs</span>  <span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>mean ± σ<span class=\"ansi-bright-black-fg\">):  </span>15.99% ±  8.67%\n\n  █<span class=\"ansi-blue-fg\">█</span>▅▃▂▁   <span class=\"ansi-green-fg\"> </span>       ▂▄▄▂▂▁▁▂▁▁▁                                 ▂\n  █<span class=\"ansi-blue-fg\">█</span>█████▇▆<span class=\"ansi-green-fg\">▇</span>▇▆▆▄▃▅▆█████████████▇▆▆▆▇▆▄▄▅▅▄▅▄▅▅▅▅▄▄▄▄▁▃▅▄▄▅▃▃▄ █\n  392 ns<span class=\"ansi-bright-black-fg\">        </span><span class=\"ansi-bright-black-fg\">Histogram: </span><span class=\"ansi-bright-black-fg ansi-bold\">log(</span><span class=\"ansi-bright-black-fg\">frequency</span><span class=\"ansi-bright-black-fg ansi-bold\">)</span><span class=\"ansi-bright-black-fg\"> by time</span>       1.9 μs <span class=\"ansi-bold\">&lt;</span>\n\n Memory estimate<span class=\"ansi-bright-black-fg\">: </span><span class=\"ansi-yellow-fg\">1.62 KiB</span>, allocs estimate<span class=\"ansi-bright-black-fg\">: </span><span class=\"ansi-yellow-fg\">2</span>.</pre>\n```\n:::\n\n:::\n:::\n\n\n\n\nFor now we can skip the full evaluation of non-positivity: the first time it encounters a positive numbers it returns false. This improves the performance a little bit.\n\n::: {#8 .cell execution_count=1}\n``` {.julia .cell-code}\n@benchmark all(i -> real(i)<=0,vbig)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>BenchmarkTools.Trial: 10000 samples with 421 evaluations per sample.\n Range <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-cyan-fg ansi-bold\">min</span> … <span class=\"ansi-magenta-fg\">max</span><span class=\"ansi-bright-black-fg\">):  </span><span class=\"ansi-cyan-fg ansi-bold\">234.442 ns</span> … <span class=\"ansi-magenta-fg\"> 1.805 μs</span>  <span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>min … max<span class=\"ansi-bright-black-fg\">): </span>0.00% … 0.00%\n Time  <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-blue-fg ansi-bold\">median</span><span class=\"ansi-bright-black-fg\">):     </span><span class=\"ansi-blue-fg ansi-bold\">241.805 ns              </span><span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>median<span class=\"ansi-bright-black-fg\">):    </span>0.00%\n Time  <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-green-fg ansi-bold\">mean</span> ± <span class=\"ansi-green-fg\">σ</span><span class=\"ansi-bright-black-fg\">):   </span><span class=\"ansi-green-fg ansi-bold\">260.356 ns</span> ± <span class=\"ansi-green-fg\">79.541 ns</span>  <span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>mean ± σ<span class=\"ansi-bright-black-fg\">):  </span>0.00% ± 0.00%\n\n  █<span class=\"ansi-blue-fg\">▇</span>▄<span class=\"ansi-green-fg\">▂</span>▁                                                        ▂\n  █<span class=\"ansi-blue-fg\">█</span>█<span class=\"ansi-green-fg\">█</span>██████▇▆▇█▆█▆▆▇▇▆▆▅▆▅▇▆▆▅▆▄▅▅▅▅▄▄▅▅▅██▆▄▆▆▆▆▄▅▅▄▄▄▁▅▃▃▄▅ █\n  234 ns<span class=\"ansi-bright-black-fg\">        </span><span class=\"ansi-bright-black-fg\">Histogram: </span><span class=\"ansi-bright-black-fg ansi-bold\">log(</span><span class=\"ansi-bright-black-fg\">frequency</span><span class=\"ansi-bright-black-fg ansi-bold\">)</span><span class=\"ansi-bright-black-fg\"> by time</span>       684 ns <span class=\"ansi-bold\">&lt;</span>\n\n Memory estimate<span class=\"ansi-bright-black-fg\">: </span><span class=\"ansi-yellow-fg\">0 bytes</span>, allocs estimate<span class=\"ansi-bright-black-fg\">: </span><span class=\"ansi-yellow-fg\">0</span>.</pre>\n```\n:::\n\n:::\n:::\n\n\n\nThis is the final form. Instead of converting into real the full vector it checks element by element if it's in the LHP. It returns false at the first failure.\n\n",
    "supporting": [
      "performance_files"
    ],
    "filters": [],
    "includes": {}
  }
}