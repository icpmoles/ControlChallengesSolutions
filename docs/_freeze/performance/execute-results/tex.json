{
  "hash": "ac52fd076ad2523a7cda4a37fadbabc1",
  "result": {
    "engine": "julia",
    "markdown": "---\ntitle: \"Performance tricks\"\ncode-fold: show\n---\n\n## Hurwitz Check\n\nCreate our nice model.\nAssume to have run the `poles` function and that you have a vector of eigenvalues. For simplicity I will create an arbitrary vector with the first 100 values in $-1$ and the last 100 values as random around $0$.\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing BenchmarkTools\n\nvbig = [zeros(ComplexF64,100).-1 ; rand(ComplexF64,100).-0.5];\n\nvbig[[1,end]]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2-element Vector{ComplexF64}:\n                -1.0 + 0.0im\n 0.00483281192168783 + 0.17985528493688896im\n```\n:::\n:::\n\n\n\n\nThen with a naive approach we check if all the  elements are in the LHP.\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n@benchmark all(real(vbig).<=0)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nBenchmarkTools.Trial: 10000 samples with 264 evaluations per sample.\n Range (min … max):  298.864 ns … 64.470 μs  ┊ GC (min … max):  0.00% … 98.48%\n Time  (median):     335.227 ns              ┊ GC (median):     0.00%\n Time  (mean ± σ):   532.914 ns ±  1.490 μs  ┊ GC (mean ± σ):  27.39% ± 11.09%\n\n  █▂▁▄▂                                                        ▁\n  ██████▇▅▄▆▃▄▄▃▄▁▁▄▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▅▄▆▅▄▃▁▃▁▃▃▁▁▁▁▁▁▁▃▁▁▁▁▄ █\n  299 ns        Histogram: log(frequency) by time       8.4 μs <\n\n Memory estimate: 1.78 KiB, allocs estimate: 6.\n```\n:::\n:::\n\n\n\nThe *whole* vector of complex numbers gets converted to real and then we check row by row if it's non-positive. The whole check one by one results in a vector with booleans that gets checked one by one if it contains false values.\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n@benchmark all(<=(0),real(vbig))\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nBenchmarkTools.Trial: 10000 samples with 205 evaluations per sample.\n Range (min … max):  366.341 ns … 82.638 μs  ┊ GC (min … max):  0.00% … 98.99%\n Time  (median):     400.976 ns              ┊ GC (median):     0.00%\n Time  (mean ± σ):   584.449 ns ±  1.508 μs  ┊ GC (mean ± σ):  15.43% ±  8.87%\n\n  ██▄▂▂         ▁▃▃▁ ▄▃▂                                       ▂\n  █████▇▇▇▇▆▅▅▅██████████▇▇▆▆▆▆▅▆▅▄▆▅▄▄▄▄▄▄▄▃▆▄▁▄▅▄▄▄▁▄▃▁▃▁▁▁▄ █\n  366 ns        Histogram: log(frequency) by time      2.27 μs <\n\n Memory estimate: 1.62 KiB, allocs estimate: 2.\n```\n:::\n:::\n\n\n\n\nFor now we can skip the full evaluation of non-positivity: the first time it encounters a positive numbers it returns false. This improves the performance a little bit.\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n@benchmark all(i -> real(i)<=0,vbig)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nBenchmarkTools.Trial: 10000 samples with 340 evaluations per sample.\n Range (min … max):  257.353 ns … 999.706 ns  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     266.765 ns               ┊ GC (median):    0.00%\n Time  (mean ± σ):   273.065 ns ±  44.546 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n  ▆█▆▄▂                                                         ▁\n  ██████▇▆▇▆▆▆▅▆▆▅▄▅▄▄▄▃▃▃▄▃▁▄▅▃▃▄▁▃▁▁▃▃▃▁▃▄▄▃▁▁▃▃▄▄▁▃▁▁▃▃▃▃▄▅▆ █\n  257 ns        Histogram: log(frequency) by time        591 ns <\n\n Memory estimate: 0 bytes, allocs estimate: 0.\n```\n:::\n:::\n\n\n\nThis is the final form. Instead of converting into real the full vector it checks element by element if it's in the LHP. It returns false at the first failure.\n\n",
    "supporting": [
      "performance_files\\figure-pdf"
    ],
    "filters": []
  }
}