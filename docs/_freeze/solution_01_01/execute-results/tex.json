{
  "hash": "cfbb4053d6b9a22475a0943e2e3a95db",
  "result": {
    "engine": "julia",
    "markdown": "---\ntitle: \"Block With Friction\"\nsubtitle: Position Control with friction. Using Pole Placement + PD.\n---\n\n## State Space representation\n\nWe can convert the set of ODE into a state space representation. The final bode plot of the block position is:\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing DiscretePIDs, ControlSystems, Plots, LinearAlgebra\n\n# System parameters\nTs = 0.02 # sampling time\nTf = 2.5; #final simulation time\ng = 9.81 #gravity\nα = 0.0 # slope\nμ = 1.0 # friction coefficient\nx_0 = -2.0 # starting position\ndx_0 = 0.0 # starting velocity\nτ = 20.0 # torque constant \n\n# State Space Matrix\nA = [0 1 0\n    0 -μ 1\n    0 0 -τ\n] * 1.0;\nB = [0\n    0\n    τ] * 1.0;\nC = [1 0 0\n    0 1 0] * 1.0\n\nsys = ss(A, B, C, 0)      # Continuous\n\nbodeplot(tf(sys))\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n![Starting Bode Plot](solution_01_01_files/figure-pdf/fig-bode-output-1.svg){#fig-bode fig-pos='H'}\n:::\n:::\n\n\n\nIt has the shape we expect from a motor + friction. Slow pole for the mass + friction and a faster pole for the current & inductance.\n\nNumerically they are:\n\n::: {#fig-pzmap .cell execution_count=1}\n``` {.julia .cell-code}\ndisplay(eigvals(A)) # -20 , -1, 0  \ndisplay(pzmap(tf(sys)))\n```\n\n::: {#fig-pzmap-1 .cell-output .cell-output-display}\n```\n3-element Vector{Float64}:\n -20.0\n  -1.0\n   0.0\n```\n\nStarting PZ map\n:::\n\n::: {.cell-output .cell-output-display}\n![](solution_01_01_files/figure-pdf/fig-pzmap-output-2.svg){#fig-pzmap-2 fig-pos='H'}\n:::\n:::\n\n\n\nIn @fig-pzmap we see that we start with all the pole in the left-half plane, which is good.\n\n## Pole Placement\n\nWe can design a controller with pole placement.\n\nFor some reason pole placement doesn't work for the observer, I use a Kalman Filter with random fast values.\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\ndisplay(observability(A, C)); #OK\ndisplay(controllability(A, B)); #OK\nϵ = 0.01;\npp = 15;\np = -2 * [pp + ϵ, pp - ϵ, (pp / 4)];\nL = real(place(sys, p, :c));\n\npoles_obs = p * 5.0\nK = place(1.0 * A', 1.0 * C', poles_obs)';\ncont = observer_controller(sys, L, K; direct=false);\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n┌ Warning: Max iterations reached\n└ @ ControlSystemsBase C:\\Users\\icpmoles\\.julia\\packages\\ControlSystemsBase\\IeuPW\\src\\synthesis.jl:310\n```\n:::\n\n::: {.cell-output .cell-output-display}\n```\n(isobservable = true, ranks = [3, 3, 3], sigma_min = [0.05255163155979671, 1.0000000000000002, 1.0])\n```\n:::\n\n::: {.cell-output .cell-output-display}\n```\n(iscontrollable = true, ranks = [3, 3, 3], sigma_min = [18.82217025796643, 0.7247734159618929, 0.46815777001494974])\n```\n:::\n:::\n\n\n\nWe can check the effect of the new controller on the loop\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nclosedLoop = feedback(sys * cont)\nprint(poles(closedLoop));\nsetPlotScale(\"dB\")\ndisplay(bodeplot(closedLoop[1, 1], 0.1:40))\ndisplay(pzmap(closedLoop))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nComplexF64[-150.09999999999997 + 0.0im, -149.89999999999995 + 0.0im, -7.500000000000134 + 0.0im, -29.979999999868912 + 0.0im, -30.020000000130636 + 0.0im, -37.50000000000044 + 0.0im]\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](solution_01_01_files/figure-pdf/cell-5-output-2.svg){fig-pos='H'}\n:::\n\n::: {.cell-output .cell-output-display}\n![](solution_01_01_files/figure-pdf/cell-5-output-3.svg){fig-pos='H'}\n:::\n:::\n\n\n\nWe can compare this to the open-loop response in @fig-bode. We can see that we achieve unitary gain throughout the whole low-frequency range.\n\nWe can convert the pole placement controller into the standard PD gain form.\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nK = L[1];\nTi = 0;\nTd = L[2] / L[1];\npid = DiscretePID(; K, Ts, Ti, Td);\n```\n:::\n\n\n\n## Simulation\n\nWe can simulate this with a motor that only outputs the position:\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nsysreal = ss(A, B, [1 0 0], 0)\nctrl = function (x, t)\n    y = (sysreal.C*x)[] # measurement\n    d = 0 * [1.0]        # disturbance\n    r = 2 * (t >= 1) # reference\n    # u = pid(r, y) # control signal\n    # u + d # Plant input is control signal + disturbance\n    # u =1\n    e = x - [r; 0; 0]\n    e[3] = 0 # torque not observable, just ignore it in the final feedback\n    u = -L * e + d\n    u = [maximum([-20 minimum([20 u])])]\nend\nt = 0:Ts:Tf\n\n\nres = lsim(sysreal, ctrl, t)\n\nplot(res, plotu=true, plotx=true, ploty=false);\nylabel!(\"u\", sp=1);\nylabel!(\"x\", sp=2);\nylabel!(\"v\", sp=3);\nylabel!(\"T\", sp=4);\n```\n:::\n\n\n\nFor more stats:\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nsi = stepinfo(res);\nplot(si);\ntitle!(\"Step Response\");\n```\n:::\n\n\n\nWe can also simulate it in a SIMULINK-like environment:\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing FMI, DifferentialEquations\nfmu = loadFMU(abspath(\"../modelica/ControlChallenges/ControlChallenges.BlockOnSlope_Challenges.Examples.WithFriction.fmu\"));\nsimData = simulateME(fmu, (0.0, 5.0); recordValues=[\"blockOnSlope.x\", \"blockOnSlope.xd\", \"blockOnSlope.usat\"]);\nunloadFMU(fmu);\nplot(simData, states=false, timeEvents=false)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\rSimulating ME-FMU ...   0%|█                             |  ETA: N/A\rSimulating ME-FMU ... 100%|██████████████████████████████| Time: 0:00:10\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](solution_01_01_files/figure-pdf/cell-9-output-2.svg){fig-pos='H'}\n:::\n:::\n\n\n\nThere is a slight difference between the `lsim` simulation and the FMU simulation. I need to recheck some stuff.\n\n{{< control target=\"TutorialBlockWithFriction\" code=\"let Kp = 337;\nlet Kd = 64;\nfunction controlFunction(block)\n{\n  return -( block.x * Kp + block.dx*Kd);\n}\" >}}\n\n",
    "supporting": [
      "solution_01_01_files\\figure-pdf"
    ],
    "filters": []
  }
}