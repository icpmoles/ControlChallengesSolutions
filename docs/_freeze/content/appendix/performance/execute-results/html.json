{
  "hash": "ddac92142873b6c99b543cba354cc8e1",
  "result": {
    "engine": "julia",
    "markdown": "---\ntitle: \"Performance tricks\"\ncode-fold: show\n---\n\n## Hurwitz Check\n\nCreate our nice model.\nAssume to have run the `poles` function and that you have a vector of eigenvalues. For simplicity I will create an arbitrary vector with the first 100 values in $-1$ and the last 100 values as random around $0$.\n\n::: {#2 .cell execution_count=1}\n``` {.julia .cell-code}\nusing BenchmarkTools\n\nvbig = [zeros(ComplexF64,100).-1 ; rand(ComplexF64,100).-0.5];\n\nvbig[[1,end]]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2-element Vector{ComplexF64}:\n                 -1.0 + 0.0im\n -0.24799024016810423 + 0.8662500972954771im\n```\n:::\n:::\n\n\n\n### `for` loop\n\n\nWith a naive approach we check if all the  elements are in the LHP: make a function that iterates and returns false if it hits a pole with positive real part.\n\n\n::: {#4 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction isHurwitz(v)\n    for i in eachindex(v)\n        if real(v[i])>0.0\n            return false\n        end\n    end\n    return true\nend\n\n@benchmark isHurwitz($(Ref(vbig))[])\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>BenchmarkTools.Trial: 10000 samples with 987 evaluations per sample.\n Range <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-cyan-fg ansi-bold\">min</span> … <span class=\"ansi-magenta-fg\">max</span><span class=\"ansi-bright-black-fg\">):  </span><span class=\"ansi-cyan-fg ansi-bold\">50.659 ns</span> … <span class=\"ansi-magenta-fg\">360.588 ns</span>  <span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>min … max<span class=\"ansi-bright-black-fg\">): </span>0.00% … 0.00%\n Time  <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-blue-fg ansi-bold\">median</span><span class=\"ansi-bright-black-fg\">):     </span><span class=\"ansi-blue-fg ansi-bold\">52.280 ns               </span><span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>median<span class=\"ansi-bright-black-fg\">):    </span>0.00%\n Time  <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-green-fg ansi-bold\">mean</span> ± <span class=\"ansi-green-fg\">σ</span><span class=\"ansi-bright-black-fg\">):   </span><span class=\"ansi-green-fg ansi-bold\">53.140 ns</span> ± <span class=\"ansi-green-fg\">  7.422 ns</span>  <span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>mean ± σ<span class=\"ansi-bright-black-fg\">):  </span>0.00% ± 0.00%\n\n  █▆▆▃<span class=\"ansi-blue-fg\">▄</span> █<span class=\"ansi-green-fg\"> </span>▅▁▁▆  ▁▁▁                                            ▂\n  ████<span class=\"ansi-blue-fg\">█</span>▇█<span class=\"ansi-green-fg\">█</span>█████▇███▆▆▇▆▆▄▄▅▄▃▄▄▄▄▁▅▁▄▃▁▃▄▁▄▄▁▁▃▃▃▄▃▃▃▁▁▁▃▄▁▄▁▃ █\n  50.7 ns<span class=\"ansi-bright-black-fg\">       </span><span class=\"ansi-bright-black-fg\">Histogram: </span><span class=\"ansi-bright-black-fg ansi-bold\">log(</span><span class=\"ansi-bright-black-fg\">frequency</span><span class=\"ansi-bright-black-fg ansi-bold\">)</span><span class=\"ansi-bright-black-fg\"> by time</span>      73.2 ns <span class=\"ansi-bold\">&lt;</span>\n\n Memory estimate<span class=\"ansi-bright-black-fg\">: </span><span class=\"ansi-yellow-fg\">0 bytes</span>, allocs estimate<span class=\"ansi-bright-black-fg\">: </span><span class=\"ansi-yellow-fg\">0</span>.</pre>\n```\n:::\n\n:::\n:::\n\n\n\nWe have our baseline. We can probably squeeze out some more performance but I'm still a Julia noob.\n\n\n### `all()`\n\n\nLet's try using some of the built-in declarative functions:\n\n::: {#6 .cell execution_count=1}\n``` {.julia .cell-code}\n@benchmark all(real($vbig).<=0.0)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>BenchmarkTools.Trial: 10000 samples with 776 evaluations per sample.\n Range <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-cyan-fg ansi-bold\">min</span> … <span class=\"ansi-magenta-fg\">max</span><span class=\"ansi-bright-black-fg\">):  </span><span class=\"ansi-cyan-fg ansi-bold\">170.876 ns</span> … <span class=\"ansi-magenta-fg\"> 18.307 μs</span>  <span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>min … max<span class=\"ansi-bright-black-fg\">): </span> 0.00% … 96.10%\n Time  <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-blue-fg ansi-bold\">median</span><span class=\"ansi-bright-black-fg\">):     </span><span class=\"ansi-blue-fg ansi-bold\">238.660 ns               </span><span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>median<span class=\"ansi-bright-black-fg\">):    </span> 0.00%\n Time  <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-green-fg ansi-bold\">mean</span> ± <span class=\"ansi-green-fg\">σ</span><span class=\"ansi-bright-black-fg\">):   </span><span class=\"ansi-green-fg ansi-bold\">411.172 ns</span> ± <span class=\"ansi-green-fg\">851.020 ns</span>  <span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>mean ± σ<span class=\"ansi-bright-black-fg\">):  </span>36.72% ± 17.16%\n\n  █<span class=\"ansi-blue-fg\">▆</span>▂<span class=\"ansi-green-fg\"> </span> ▁▁                                                       ▁\n  █<span class=\"ansi-blue-fg\">█</span>█<span class=\"ansi-green-fg\">█</span>▇██▆▆▁▃▃▁▃▁▁▁▃▁▁▁▁▆▆▆▅▃▃▃▁▁▃▁▃▃▅▆▆▆▆▇▇▆▅▅▅▄▅▅▅▅▅▄▅▅▅▅▄▆▆▆ █\n  171 ns<span class=\"ansi-bright-black-fg\">        </span><span class=\"ansi-bright-black-fg\">Histogram: </span><span class=\"ansi-bright-black-fg ansi-bold\">log(</span><span class=\"ansi-bright-black-fg\">frequency</span><span class=\"ansi-bright-black-fg ansi-bold\">)</span><span class=\"ansi-bright-black-fg\"> by time</span>       5.54 μs <span class=\"ansi-bold\">&lt;</span>\n\n Memory estimate<span class=\"ansi-bright-black-fg\">: </span><span class=\"ansi-yellow-fg\">1.75 KiB</span>, allocs estimate<span class=\"ansi-bright-black-fg\">: </span><span class=\"ansi-yellow-fg\">5</span>.</pre>\n```\n:::\n\n:::\n:::\n\n\n\nSimple `all()`, when given a tuple it checks if all the values are `True`, otherwise it stops when it encounters the first `False`. \n\nWe can see that it's a tad slower. This is because it's creating a new vector with just the real parts, then it's creating a new vector with only the boolean results and then it's checking if there are any False results. \n\nThis results in a lot of allocations and wasted resources.\n\n\n::: {#8 .cell execution_count=1}\n``` {.julia .cell-code}\n@benchmark all(<=(0.0),real($vbig))\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>BenchmarkTools.Trial: 10000 samples with 796 evaluations per sample.\n Range <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-cyan-fg ansi-bold\">min</span> … <span class=\"ansi-magenta-fg\">max</span><span class=\"ansi-bright-black-fg\">):  </span><span class=\"ansi-cyan-fg ansi-bold\">150.000 ns</span> … <span class=\"ansi-magenta-fg\"> 24.051 μs</span>  <span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>min … max<span class=\"ansi-bright-black-fg\">): </span> 0.00% … 98.68%\n Time  <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-blue-fg ansi-bold\">median</span><span class=\"ansi-bright-black-fg\">):     </span><span class=\"ansi-blue-fg ansi-bold\">215.327 ns               </span><span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>median<span class=\"ansi-bright-black-fg\">):    </span> 0.00%\n Time  <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-green-fg ansi-bold\">mean</span> ± <span class=\"ansi-green-fg\">σ</span><span class=\"ansi-bright-black-fg\">):   </span><span class=\"ansi-green-fg ansi-bold\">310.133 ns</span> ± <span class=\"ansi-green-fg\">551.533 ns</span>  <span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>mean ± σ<span class=\"ansi-bright-black-fg\">):  </span>22.76% ± 15.72%\n\n  ▂█<span class=\"ansi-blue-fg\">▇</span>▄▂<span class=\"ansi-green-fg\"> </span>        ▃▁                                           ▁▁ ▂\n  ██<span class=\"ansi-blue-fg\">█</span>██<span class=\"ansi-green-fg\">▇</span>▇▆▅▅▃▃▃▇███▆▆▅▆▅▆▅▅▄▅▅▄▁▁▃▁▁▁▃▁▁▁▁▁▃▁▁▁▁▁▁▁▁▁▁▁▃▁▄▅▇███ █\n  150 ns<span class=\"ansi-bright-black-fg\">        </span><span class=\"ansi-bright-black-fg\">Histogram: </span><span class=\"ansi-bright-black-fg ansi-bold\">log(</span><span class=\"ansi-bright-black-fg\">frequency</span><span class=\"ansi-bright-black-fg ansi-bold\">)</span><span class=\"ansi-bright-black-fg\"> by time</span>       2.14 μs <span class=\"ansi-bold\">&lt;</span>\n\n Memory estimate<span class=\"ansi-bright-black-fg\">: </span><span class=\"ansi-yellow-fg\">1.62 KiB</span>, allocs estimate<span class=\"ansi-bright-black-fg\">: </span><span class=\"ansi-yellow-fg\">2</span>.</pre>\n```\n:::\n\n:::\n:::\n\n\n\n\nA smarter way is to skip on of the allocations by creating the vector of real parts and then checking row by row if the non-positivity check fails.\n\n\n::: {#10 .cell execution_count=1}\n``` {.julia .cell-code}\n@benchmark all(i -> real(i)<=0.0,$vbig)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>BenchmarkTools.Trial: 10000 samples with 987 evaluations per sample.\n Range <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-cyan-fg ansi-bold\">min</span> … <span class=\"ansi-magenta-fg\">max</span><span class=\"ansi-bright-black-fg\">):  </span><span class=\"ansi-cyan-fg ansi-bold\">49.544 ns</span> … <span class=\"ansi-magenta-fg\">219.656 ns</span>  <span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>min … max<span class=\"ansi-bright-black-fg\">): </span>0.00% … 0.00%\n Time  <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-blue-fg ansi-bold\">median</span><span class=\"ansi-bright-black-fg\">):     </span><span class=\"ansi-blue-fg ansi-bold\">51.570 ns               </span><span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>median<span class=\"ansi-bright-black-fg\">):    </span>0.00%\n Time  <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-green-fg ansi-bold\">mean</span> ± <span class=\"ansi-green-fg\">σ</span><span class=\"ansi-bright-black-fg\">):   </span><span class=\"ansi-green-fg ansi-bold\">53.682 ns</span> ± <span class=\"ansi-green-fg\"> 11.983 ns</span>  <span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>mean ± σ<span class=\"ansi-bright-black-fg\">):  </span>0.00% ± 0.00%\n\n  ▁█<span class=\"ansi-blue-fg\">▆</span>▂<span class=\"ansi-green-fg\">▃</span>▂                                                    ▁  ▁\n  ██<span class=\"ansi-blue-fg\">█</span>█<span class=\"ansi-green-fg\">█</span>██▆▇▆▅▅▄▄▇▅▅▅▅▆▄▅▅▄▁▄▄▄▄▃▆▄▄▄▄▃▅▃▄▁▄▃▃▅▃▃▁▁▄▁▄▃▃▁▃▄▅▁██ █\n  49.5 ns<span class=\"ansi-bright-black-fg\">       </span><span class=\"ansi-bright-black-fg\">Histogram: </span><span class=\"ansi-bright-black-fg ansi-bold\">log(</span><span class=\"ansi-bright-black-fg\">frequency</span><span class=\"ansi-bright-black-fg ansi-bold\">)</span><span class=\"ansi-bright-black-fg\"> by time</span>       116 ns <span class=\"ansi-bold\">&lt;</span>\n\n Memory estimate<span class=\"ansi-bright-black-fg\">: </span><span class=\"ansi-yellow-fg\">0 bytes</span>, allocs estimate<span class=\"ansi-bright-black-fg\">: </span><span class=\"ansi-yellow-fg\">0</span>.</pre>\n```\n:::\n\n:::\n:::\n\n\nWe can do better: Instead of converting into real the full vector it checks element by element if it's in the LHP. It returns false at the first failure. We finally have a comparable result to the benchmark function but in a more compact way. \n\nIs it cleaner? That's subjective.\n\n### `mapreduce()`\n\nFinally we try the MapReduce approach. This allows a better utilization of your processor without the necessity of learning parallel programming.\n\n::: {#12 .cell execution_count=1}\n``` {.julia .cell-code}\n@benchmark mapreduce(i->real(i)<=0.0, &, $vbig)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>BenchmarkTools.Trial: 10000 samples with 992 evaluations per sample.\n Range <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-cyan-fg ansi-bold\">min</span> … <span class=\"ansi-magenta-fg\">max</span><span class=\"ansi-bright-black-fg\">):  </span><span class=\"ansi-cyan-fg ansi-bold\">42.036 ns</span> … <span class=\"ansi-magenta-fg\">633.871 ns</span>  <span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>min … max<span class=\"ansi-bright-black-fg\">): </span>0.00% … 0.00%\n Time  <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-blue-fg ansi-bold\">median</span><span class=\"ansi-bright-black-fg\">):     </span><span class=\"ansi-blue-fg ansi-bold\">42.339 ns               </span><span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>median<span class=\"ansi-bright-black-fg\">):    </span>0.00%\n Time  <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-green-fg ansi-bold\">mean</span> ± <span class=\"ansi-green-fg\">σ</span><span class=\"ansi-bright-black-fg\">):   </span><span class=\"ansi-green-fg ansi-bold\">43.741 ns</span> ± <span class=\"ansi-green-fg\"> 10.518 ns</span>  <span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>mean ± σ<span class=\"ansi-bright-black-fg\">):  </span>0.00% ± 0.00%\n\n  <span class=\"ansi-blue-fg\">█</span>▄<span class=\"ansi-green-fg\">▁</span>▂▂                                                        ▁\n  <span class=\"ansi-blue-fg\">█</span>█<span class=\"ansi-green-fg\">█</span>██▇█▆▆▆▆▅▇▄▄▁▇▇▄▃▄▅▃▃▁▁▁▄▁▃▁▁▁▃▁▁▁▄▁▁▁▃▁▁▃▁▁▃▁▁▁▁▁▃▃▃▁▃▃█ █\n  42 ns<span class=\"ansi-bright-black-fg\">         </span><span class=\"ansi-bright-black-fg\">Histogram: </span><span class=\"ansi-bright-black-fg ansi-bold\">log(</span><span class=\"ansi-bright-black-fg\">frequency</span><span class=\"ansi-bright-black-fg ansi-bold\">)</span><span class=\"ansi-bright-black-fg\"> by time</span>      95.4 ns <span class=\"ansi-bold\">&lt;</span>\n\n Memory estimate<span class=\"ansi-bright-black-fg\">: </span><span class=\"ansi-yellow-fg\">0 bytes</span>, allocs estimate<span class=\"ansi-bright-black-fg\">: </span><span class=\"ansi-yellow-fg\">0</span>.</pre>\n```\n:::\n\n:::\n:::\n\n\n\nWe squeeze the last bit of performance and beat the initial benchmark, not by much but still appreciable.\n\n",
    "supporting": [
      "performance_files"
    ],
    "filters": [],
    "includes": {}
  }
}