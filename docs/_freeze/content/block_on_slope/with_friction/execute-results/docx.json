{
  "hash": "0281cd6b71cd065ad08b5196a8d48d9c",
  "result": {
    "engine": "julia",
    "markdown": "---\ntitle: \"Block With Friction\"\nsubtitle: Position Control with friction. Using Pole Placement + PD.\n---\n\n## Response Analysis\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing CCS\nusing ControlSystems, Plots, LinearAlgebra, RobustAndOptimalControl\nCCS.setupEnv()\n\ncontSys = CCS.blockModel.csys(;g = 0, α = 0 , μ = 1, τ =20)\nplot!(bodeplot(contSys[1,1]),pzmap(contSys))\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n![Starting Bode Plot and PZ Map](with_friction_files/figure-docx/start-bode-output-1.svg){#start-bode}\n:::\n:::\n\n\n\nIt has the shape we expect from a motor + friction. Slow pole for the mass + friction and a faster pole for the current & inductance.\n\nNumerically they are:\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\ndisplay(eigvals(contSys.A))\n```\n\n::: {.cell-output .cell-output-display}\n```\n3-element Vector{Float64}:\n -20.0\n  -1.0\n   0.0\n```\n:::\n:::\n\n\n\nWe see that we start with all the poles in the left-half plane, which is good.\n\n## Pole Placement\n\nWe can design a controller with pole placement.\n\nFor some reason pole placement doesn't work for the observer, I use a Kalman Filter with random fast values.\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nobservability(contSys.A,contSys.C).isobservable || error(\"System is not observable\")\ncontrollability(contSys.A,contSys.B).iscontrollable || error(\"System is not controllable\")\n\nε = 0.01;\npp = 15.0;\npoles_cont = - [pp + ε, pp - ε, pp];\nL = real(place(contSys, poles_cont, :c));\n\n\npoles_obs = poles_cont * 10.0;\nK = place(contSys, poles_obs, :o)\nobs_controller = observer_controller(contSys, L, K; direct=false);\nfsf_controller = named_ss(obs_controller, u = [:ref_S, :ref_V], y = [:u]);\n```\n:::\n\n\n\nWe can check the effect of the new controller on the loop\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nclosedLoop = feedback( contSys * fsf_controller);\nprint(poles(closedLoop));\nsetPlotScale(\"dB\")\nplot!(bodeplot(closedLoop[1,1], 0.1:40), pzmap(closedLoop))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nComplexF64[-14.990000366343788 + 0.0im, -14.999999266673722 + 0.0im, -15.010000366982666 + 0.0im, -149.99999999999986 + 0.0im, -150.10000000002432 + 0.0im, -149.8999999999607 + 0.0im]\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](with_friction_files/figure-docx/cell-5-output-2.svg){}\n:::\n:::\n\n\n\nWe can compare this to the open-loop response in @start-bode. We can see that we achieve unitary gain throughout the whole low-frequency range.\n\nWe can convert the pole placement controller into the standard PD gain form.\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing DiscretePIDs\nTs = 0.02 # sampling time\nTf = 2.5; #final simulation time\n\nK = L[1];\nTi = 0;\nTd = L[2] / L[1];\n\npid = DiscretePID(; K, Ts, Ti, Td);\n```\n:::\n\n\n\n\n## Simulation\n\nWe can simulate this with a motor that only outputs the position:\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nsysreal = ss(contSys.A, contSys.B, [1 0 0], 0.0)\nctrl = function (x, t)\n    y = (sysreal.C*x)[] # measurement\n    d = 0 * [1.0]        # disturbance\n    r = 2.0 * (t >= 1) # reference\n    # u = pid(r, y) # control signal\n    # u + d # Plant input is control signal + disturbance\n    # u =1\n    e = x - [r; 0.0; 0.0]\n    e[3] = 0.0 # torque not observable, just ignore it in the final feedback\n    u = -L * e + d\n    u = [maximum([-20.0 minimum([20.0 u])])]\nend\nt = 0:Ts:Tf\n\nres = lsim(sysreal, ctrl, t)\n\ndisplay(plot(res, \n    plotu=true, \n    plotx=true, \n    ploty=false\n    ))\nylabel!(\"u\", sp=1);\nylabel!(\"x\", sp=2);\nylabel!(\"v\", sp=3);\nylabel!(\"T\", sp=4);\n```\n\n::: {.cell-output .cell-output-display}\n![](with_friction_files/figure-docx/cell-7-output-1.svg){}\n:::\n:::\n\n\n\nFor more stats:\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nsi = stepinfo(res);\nplot(si);title!(\"Step Response\")\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](with_friction_files/figure-docx/cell-8-output-1.svg){}\n:::\n:::\n\n\n\nWe can also simulate it in a SIMULINK-like environment:\n\n::: {.cell freeze='true' execution_count=1}\n``` {.julia .cell-code}\nusing FMI, DifferentialEquations\nfmuPath = abspath(joinpath(@__DIR__,\n  \"..\",\"..\",\"..\",\n  \"modelica\",\n  \"ControlChallenges\",\n  \"ControlChallenges.BlockOnSlope_Challenges.Examples.WithFriction.fmu\"))\nfmu = loadFMU(fmuPath);\nsimData = simulateME(\n    fmu,\n    (0.0, 5.0);\n    recordValues=[\"blockOnSlope.x\", \n    \"blockOnSlope.xd\", \n    \"blockOnSlope.usat\"],\n    showProgress=false);\nunloadFMU(fmu);\nplot(simData, states=false, timeEvents=false)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](with_friction_files/figure-docx/cell-9-output-1.svg){}\n:::\n:::\n\n\n\nThere is a slight difference between the `lsim` simulation and the FMU simulation. I need to recheck some stuff.\n\n{{< control target=\"TutorialBlockWithFriction\" code=\"let Kp = 337;\nlet Kd = 64;\nfunction controlFunction(block)\n{\n  return -( block.x * Kp + block.dx*Kd);\n}\" >}}\n\n",
    "supporting": [
      "with_friction_files\\figure-docx"
    ],
    "filters": []
  }
}