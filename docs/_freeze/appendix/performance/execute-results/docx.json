{
  "hash": "ac52fd076ad2523a7cda4a37fadbabc1",
  "result": {
    "engine": "julia",
    "markdown": "---\ntitle: \"Performance tricks\"\ncode-fold: show\n---\n\n## Hurwitz Check\n\nCreate our nice model.\nAssume to have run the `poles` function and that you have a vector of eigenvalues. For simplicity I will create an arbitrary vector with the first 100 values in $-1$ and the last 100 values as random around $0$.\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing BenchmarkTools\n\nvbig = [zeros(ComplexF64,100).-1 ; rand(ComplexF64,100).-0.5];\n\nvbig[[1,end]]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2-element Vector{ComplexF64}:\n                -1.0 + 0.0im\n -0.4331044312441319 + 0.2962239553125152im\n```\n:::\n:::\n\n\n\n\nThen with a naive approach we check if all the  elements are in the LHP.\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n@benchmark all(real(vbig).<=0)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nBenchmarkTools.Trial: 10000 samples with 226 evaluations per sample.\n Range (min … max):  323.451 ns … 71.935 μs  ┊ GC (min … max):  0.00% … 98.29%\n Time  (median):     361.947 ns              ┊ GC (median):     0.00%\n Time  (mean ± σ):   582.819 ns ±  1.713 μs  ┊ GC (mean ± σ):  27.61% ± 10.74%\n\n  █▃ ▂▁▂▂                                                      ▁\n  ████████▆▆▅▅▅▅▄▄▅▃▄▃▃▁▃▁▁▃▁▃▁▃▁▁▁▃▁▁▁▁▁▃▁▁▁▁▁▁▁▁▃▅▄▁▁▅▅▄▄▃▃▄ █\n  323 ns        Histogram: log(frequency) by time       7.3 μs <\n\n Memory estimate: 1.78 KiB, allocs estimate: 6.\n```\n:::\n:::\n\n\n\nThe *whole* vector of complex numbers gets converted to real and then we check row by row if it's non-positive. The whole check one by one results in a vector with booleans that gets checked one by one if it contains false values.\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n@benchmark all(<=(0),real(vbig))\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nBenchmarkTools.Trial: 10000 samples with 200 evaluations per sample.\n Range (min … max):  395.000 ns … 102.246 μs  ┊ GC (min … max):  0.00% … 99.04%\n Time  (median):     457.500 ns               ┊ GC (median):     0.00%\n Time  (mean ± σ):   667.069 ns ±   1.728 μs  ┊ GC (mean ± σ):  15.54% ±  9.07%\n\n  █▅▁ ▃▄▃▁                                                      ▁\n  ███▇█████▇▇▆▆▅▆▆▄▄▅▄▃▄▁▄▃▃▄▄▁▃▃▁▁▁▃▃▃▁▁▃▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▃ █\n  395 ns        Histogram: log(frequency) by time          7 μs <\n\n Memory estimate: 1.62 KiB, allocs estimate: 2.\n```\n:::\n:::\n\n\n\n\nFor now we can skip the full evaluation of non-positivity: the first time it encounters a positive numbers it returns false. This improves the performance a little bit.\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n@benchmark all(i -> real(i)<=0,vbig)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nBenchmarkTools.Trial: 10000 samples with 328 evaluations per sample.\n Range (min … max):  257.012 ns …  1.215 μs  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     270.122 ns              ┊ GC (median):    0.00%\n Time  (mean ± σ):   279.606 ns ± 55.243 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n   █▃▁                                                          \n  ▆███▇▃▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▂▁▂▂▂▂▂▂▂▁▂▂▂▂▁▁▂▂▁▂▂▂▁▂▂▂▁▁▂▁▂▂▂▂▂▂▂▂ ▂\n  257 ns          Histogram: frequency by time          603 ns <\n\n Memory estimate: 0 bytes, allocs estimate: 0.\n```\n:::\n:::\n\n\n\nThis is the final form. Instead of converting into real the full vector it checks element by element if it's in the LHP. It returns false at the first failure.\n\n",
    "supporting": [
      "performance_files\\figure-docx"
    ],
    "filters": []
  }
}