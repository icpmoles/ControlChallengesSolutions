{
  "hash": "ddac92142873b6c99b543cba354cc8e1",
  "result": {
    "engine": "julia",
    "markdown": "---\ntitle: \"Performance tricks\"\ncode-fold: show\n---\n\n## Hurwitz Check\n\nCreate our nice model.\nAssume to have run the `poles` function and that you have a vector of eigenvalues. For simplicity I will create an arbitrary vector with the first 100 values in $-1$ and the last 100 values as random around $0$.\n\n::: {#2 .cell execution_count=1}\n``` {.julia .cell-code}\nusing BenchmarkTools\n\nvbig = [zeros(ComplexF64,100).-1 ; rand(ComplexF64,100).-0.5];\n\nvbig[[1,end]]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2-element Vector{ComplexF64}:\n                 -1.0 + 0.0im\n -0.20895541504670545 + 0.472586989973956im\n```\n:::\n:::\n\n\n\n### `for` loop\n\n\nWith a naive approach we check if all the  elements are in the LHP: make a function that iterates and returns false if it hits a pole with positive real part.\n\n\n::: {#4 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction isHurwitz(v)\n    for i in eachindex(v)\n        if real(v[i])>0.0\n            return false\n        end\n    end\n    return true\nend\n\n@benchmark isHurwitz($(Ref(vbig))[])\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>BenchmarkTools.Trial: 10000 samples with 987 evaluations per sample.\n Range <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-cyan-fg ansi-bold\">min</span> … <span class=\"ansi-magenta-fg\">max</span><span class=\"ansi-bright-black-fg\">):  </span><span class=\"ansi-cyan-fg ansi-bold\">50.557 ns</span> … <span class=\"ansi-magenta-fg\">389.564 ns</span>  <span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>min … max<span class=\"ansi-bright-black-fg\">): </span>0.00% … 0.00%\n Time  <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-blue-fg ansi-bold\">median</span><span class=\"ansi-bright-black-fg\">):     </span><span class=\"ansi-blue-fg ansi-bold\">53.698 ns               </span><span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>median<span class=\"ansi-bright-black-fg\">):    </span>0.00%\n Time  <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-green-fg ansi-bold\">mean</span> ± <span class=\"ansi-green-fg\">σ</span><span class=\"ansi-bright-black-fg\">):   </span><span class=\"ansi-green-fg ansi-bold\">56.542 ns</span> ± <span class=\"ansi-green-fg\"> 13.874 ns</span>  <span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>mean ± σ<span class=\"ansi-bright-black-fg\">):  </span>0.00% ± 0.00%\n\n   ▂█<span class=\"ansi-blue-fg\">▇</span>▃<span class=\"ansi-green-fg\">▃</span>▂  ▁                                                 ▂ ▂\n  ▆██<span class=\"ansi-blue-fg\">█</span>█<span class=\"ansi-green-fg\">█</span>██▇█▅▇▇▅▅▅▆▅▄▇▅▅▅▆▄▅▄▄▅▁▄▅▄▁▁▄▃▃▄▄▅▃▅▄▄▄▁▁▁▁▃▁▃▅▄▄▃▁▄█ █\n  50.6 ns<span class=\"ansi-bright-black-fg\">       </span><span class=\"ansi-bright-black-fg\">Histogram: </span><span class=\"ansi-bright-black-fg ansi-bold\">log(</span><span class=\"ansi-bright-black-fg\">frequency</span><span class=\"ansi-bright-black-fg ansi-bold\">)</span><span class=\"ansi-bright-black-fg\"> by time</span>       121 ns <span class=\"ansi-bold\">&lt;</span>\n\n Memory estimate<span class=\"ansi-bright-black-fg\">: </span><span class=\"ansi-yellow-fg\">0 bytes</span>, allocs estimate<span class=\"ansi-bright-black-fg\">: </span><span class=\"ansi-yellow-fg\">0</span>.</pre>\n```\n:::\n\n:::\n:::\n\n\n\nWe have our baseline. We can probably squeeze out some more performance but I'm still a Julia noob.\n\n\n### `all()`\n\n\nLet's try using some of the built-in declarative functions:\n\n::: {#6 .cell execution_count=1}\n``` {.julia .cell-code}\n@benchmark all(real($vbig).<=0.0)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>BenchmarkTools.Trial: 10000 samples with 755 evaluations per sample.\n Range <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-cyan-fg ansi-bold\">min</span> … <span class=\"ansi-magenta-fg\">max</span><span class=\"ansi-bright-black-fg\">):  </span><span class=\"ansi-cyan-fg ansi-bold\">179.205 ns</span> … <span class=\"ansi-magenta-fg\"> 26.772 μs</span>  <span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>min … max<span class=\"ansi-bright-black-fg\">): </span> 0.00% … 98.51%\n Time  <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-blue-fg ansi-bold\">median</span><span class=\"ansi-bright-black-fg\">):     </span><span class=\"ansi-blue-fg ansi-bold\">252.848 ns               </span><span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>median<span class=\"ansi-bright-black-fg\">):    </span> 0.00%\n Time  <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-green-fg ansi-bold\">mean</span> ± <span class=\"ansi-green-fg\">σ</span><span class=\"ansi-bright-black-fg\">):   </span><span class=\"ansi-green-fg ansi-bold\">422.784 ns</span> ± <span class=\"ansi-green-fg\">879.189 ns</span>  <span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>mean ± σ<span class=\"ansi-bright-black-fg\">):  </span>32.07% ± 16.25%\n\n  ▇<span class=\"ansi-blue-fg\">█</span>▄▁<span class=\"ansi-green-fg\"> </span> ▁▄▁                                                     ▂\n  █<span class=\"ansi-blue-fg\">█</span>██<span class=\"ansi-green-fg\">█</span>▇███▇▇▆▆▆▆▆▄▄▄▃▁▁▁▁▃▁▁▁▁▁▁▁▁▁▁▁▁▁▁▃▁▁▁▁▃▁▁▁▃▃▄▆▆▇▆▇▇▇██▆ █\n  179 ns<span class=\"ansi-bright-black-fg\">        </span><span class=\"ansi-bright-black-fg\">Histogram: </span><span class=\"ansi-bright-black-fg ansi-bold\">log(</span><span class=\"ansi-bright-black-fg\">frequency</span><span class=\"ansi-bright-black-fg ansi-bold\">)</span><span class=\"ansi-bright-black-fg\"> by time</span>       4.19 μs <span class=\"ansi-bold\">&lt;</span>\n\n Memory estimate<span class=\"ansi-bright-black-fg\">: </span><span class=\"ansi-yellow-fg\">1.75 KiB</span>, allocs estimate<span class=\"ansi-bright-black-fg\">: </span><span class=\"ansi-yellow-fg\">5</span>.</pre>\n```\n:::\n\n:::\n:::\n\n\n\nSimple `all()`, when given a tuple it checks if all the values are `True`, otherwise it stops when it encounters the first `False`. \n\nWe can see that it's a tad slower. This is because it's creating a new vector with just the real parts, then it's creating a new vector with only the boolean results and then it's checking if there are any False results. \n\nThis results in a lot of allocations and wasted resources.\n\n\n::: {#8 .cell execution_count=1}\n``` {.julia .cell-code}\n@benchmark all(<=(0.0),real($vbig))\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>BenchmarkTools.Trial: 10000 samples with 776 evaluations per sample.\n Range <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-cyan-fg ansi-bold\">min</span> … <span class=\"ansi-magenta-fg\">max</span><span class=\"ansi-bright-black-fg\">):  </span><span class=\"ansi-cyan-fg ansi-bold\">156.314 ns</span> … <span class=\"ansi-magenta-fg\"> 27.794 μs</span>  <span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>min … max<span class=\"ansi-bright-black-fg\">): </span> 0.00% … 98.27%\n Time  <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-blue-fg ansi-bold\">median</span><span class=\"ansi-bright-black-fg\">):     </span><span class=\"ansi-blue-fg ansi-bold\">218.814 ns               </span><span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>median<span class=\"ansi-bright-black-fg\">):    </span> 0.00%\n Time  <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-green-fg ansi-bold\">mean</span> ± <span class=\"ansi-green-fg\">σ</span><span class=\"ansi-bright-black-fg\">):   </span><span class=\"ansi-green-fg ansi-bold\">343.515 ns</span> ± <span class=\"ansi-green-fg\">647.150 ns</span>  <span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>mean ± σ<span class=\"ansi-bright-black-fg\">):  </span>23.74% ± 15.37%\n\n  ▄█<span class=\"ansi-blue-fg\">▆</span>▃▂<span class=\"ansi-green-fg\">▁</span>▁    ▃▁▁▁▁                                              ▁\n  ██<span class=\"ansi-blue-fg\">█</span>██<span class=\"ansi-green-fg\">█</span>██▇▇▆█████▇▆▆▅▅▅▄▃▄▄▅▄▄▄▁▅▃▃▁▁▁▁▁▄▃▁▁▁▁▁▁▁▃▁▄▆▇▇███▆▅▅▅ █\n  156 ns<span class=\"ansi-bright-black-fg\">        </span><span class=\"ansi-bright-black-fg\">Histogram: </span><span class=\"ansi-bright-black-fg ansi-bold\">log(</span><span class=\"ansi-bright-black-fg\">frequency</span><span class=\"ansi-bright-black-fg ansi-bold\">)</span><span class=\"ansi-bright-black-fg\"> by time</span>       2.58 μs <span class=\"ansi-bold\">&lt;</span>\n\n Memory estimate<span class=\"ansi-bright-black-fg\">: </span><span class=\"ansi-yellow-fg\">1.62 KiB</span>, allocs estimate<span class=\"ansi-bright-black-fg\">: </span><span class=\"ansi-yellow-fg\">2</span>.</pre>\n```\n:::\n\n:::\n:::\n\n\n\n\nA smarter way is to skip on of the allocations by creating the vector of real parts and then checking row by row if the non-positivity check fails.\n\n\n::: {#10 .cell execution_count=1}\n``` {.julia .cell-code}\n@benchmark all(i -> real(i)<=0.0,$vbig)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>BenchmarkTools.Trial: 10000 samples with 987 evaluations per sample.\n Range <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-cyan-fg ansi-bold\">min</span> … <span class=\"ansi-magenta-fg\">max</span><span class=\"ansi-bright-black-fg\">):  </span><span class=\"ansi-cyan-fg ansi-bold\">49.139 ns</span> … <span class=\"ansi-magenta-fg\">826.545 ns</span>  <span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>min … max<span class=\"ansi-bright-black-fg\">): </span>0.00% … 0.00%\n Time  <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-blue-fg ansi-bold\">median</span><span class=\"ansi-bright-black-fg\">):     </span><span class=\"ansi-blue-fg ansi-bold\">51.165 ns               </span><span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>median<span class=\"ansi-bright-black-fg\">):    </span>0.00%\n Time  <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-green-fg ansi-bold\">mean</span> ± <span class=\"ansi-green-fg\">σ</span><span class=\"ansi-bright-black-fg\">):   </span><span class=\"ansi-green-fg ansi-bold\">55.618 ns</span> ± <span class=\"ansi-green-fg\"> 22.280 ns</span>  <span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>mean ± σ<span class=\"ansi-bright-black-fg\">):  </span>0.00% ± 0.00%\n\n  ▆<span class=\"ansi-blue-fg\">█</span>▅▃<span class=\"ansi-green-fg\">▂</span>▁ ▁                                ▁▂                   ▁\n  █<span class=\"ansi-blue-fg\">█</span>██<span class=\"ansi-green-fg\">█</span>█▇█▇▇▅▄▆▅▆▇▅▃▆▅▅▄▅▆▄▅▄▅▄▄▄▄▄▃▃▅▅▃▆▆██▇▅▅▄▅▄▄▅▅▄▅▄▅▄▃▁▁▅ █\n  49.1 ns<span class=\"ansi-bright-black-fg\">       </span><span class=\"ansi-bright-black-fg\">Histogram: </span><span class=\"ansi-bright-black-fg ansi-bold\">log(</span><span class=\"ansi-bright-black-fg\">frequency</span><span class=\"ansi-bright-black-fg ansi-bold\">)</span><span class=\"ansi-bright-black-fg\"> by time</span>       145 ns <span class=\"ansi-bold\">&lt;</span>\n\n Memory estimate<span class=\"ansi-bright-black-fg\">: </span><span class=\"ansi-yellow-fg\">0 bytes</span>, allocs estimate<span class=\"ansi-bright-black-fg\">: </span><span class=\"ansi-yellow-fg\">0</span>.</pre>\n```\n:::\n\n:::\n:::\n\n\nWe can do better: Instead of converting into real the full vector it checks element by element if it's in the LHP. It returns false at the first failure. We finally have a comparable result to the benchmark function but in a more compact way. \n\nIs it cleaner? That's subjective.\n\n### `mapreduce()`\n\nFinally we try the MapReduce approach. This allows a better utilization of your processor without the necessity of learning parallel programming.\n\n::: {#12 .cell execution_count=1}\n``` {.julia .cell-code}\n@benchmark mapreduce(i->real(i)<=0.0, &, $vbig)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>BenchmarkTools.Trial: 10000 samples with 990 evaluations per sample.\n Range <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-cyan-fg ansi-bold\">min</span> … <span class=\"ansi-magenta-fg\">max</span><span class=\"ansi-bright-black-fg\">):  </span><span class=\"ansi-cyan-fg ansi-bold\">43.737 ns</span> … <span class=\"ansi-magenta-fg\">747.172 ns</span>  <span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>min … max<span class=\"ansi-bright-black-fg\">): </span>0.00% … 0.00%\n Time  <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-blue-fg ansi-bold\">median</span><span class=\"ansi-bright-black-fg\">):     </span><span class=\"ansi-blue-fg ansi-bold\">44.343 ns               </span><span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>median<span class=\"ansi-bright-black-fg\">):    </span>0.00%\n Time  <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-green-fg ansi-bold\">mean</span> ± <span class=\"ansi-green-fg\">σ</span><span class=\"ansi-bright-black-fg\">):   </span><span class=\"ansi-green-fg ansi-bold\">48.952 ns</span> ± <span class=\"ansi-green-fg\"> 20.482 ns</span>  <span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>mean ± σ<span class=\"ansi-bright-black-fg\">):  </span>0.00% ± 0.00%\n\n  <span class=\"ansi-blue-fg\">█</span>▂▃▁<span class=\"ansi-green-fg\"> </span>                                 ▁                      ▁\n  <span class=\"ansi-blue-fg\">█</span>███<span class=\"ansi-green-fg\">█</span>▆▆▆█▆▅▅▅█▅▇▄█▅▆▅▆▆▄▇▆▄█▄▅▇▇▄▄▆▅▅▆█▇▄▅▄▆▄▄▆▄▅▅▄▄▃▄▁▅▆▄▅▄ █\n  43.7 ns<span class=\"ansi-bright-black-fg\">       </span><span class=\"ansi-bright-black-fg\">Histogram: </span><span class=\"ansi-bright-black-fg ansi-bold\">log(</span><span class=\"ansi-bright-black-fg\">frequency</span><span class=\"ansi-bright-black-fg ansi-bold\">)</span><span class=\"ansi-bright-black-fg\"> by time</span>       131 ns <span class=\"ansi-bold\">&lt;</span>\n\n Memory estimate<span class=\"ansi-bright-black-fg\">: </span><span class=\"ansi-yellow-fg\">0 bytes</span>, allocs estimate<span class=\"ansi-bright-black-fg\">: </span><span class=\"ansi-yellow-fg\">0</span>.</pre>\n```\n:::\n\n:::\n:::\n\n\n\nWe squeeze the last bit of performance and beat the initial benchmark, not by much but still appreciable.\n\n",
    "supporting": [
      "performance_files"
    ],
    "filters": [],
    "includes": {}
  }
}